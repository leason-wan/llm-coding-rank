æˆ‘å°†ä¸ºæ‚¨åˆ›å»ºä¸€ä¸ªéœ‡æ’¼çš„3Då»ºç­‘æ‹†é™¤æ¼”ç¤ºã€‚è¿™ä¸ªé¡¹ç›®å°†åŒ…å«ç‰©ç†å¼•æ“ã€ç²’å­ç³»ç»Ÿå’Œå®Œæ•´çš„äº¤äº’æ§åˆ¶ã€‚

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éœ‡æ’¼3Då»ºç­‘æ‹†é™¤æ¼”ç¤º</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #explodeBtn {
            background: linear-gradient(45deg, #ff1744, #d50000);
            font-size: 16px;
            padding: 15px 30px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 23, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0); }
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">æ­£åœ¨æ„å»ºå»ºç­‘ç‰©...</div>
        
        <div id="controls">
            <div class="control-group">
                <button id="explodeBtn" disabled>ğŸ’¥ å¼•çˆ†å»ºç­‘</button>
            </div>
            <div class="control-group">
                <button id="resetBtn">ğŸ”„ é‡ç½®åœºæ™¯</button>
                <button id="cameraBtn">ğŸ“±åˆ‡æ¢è§†è§’</button>
            </div>
            <div class="control-group">
                <small>é¼ æ ‡å·¦é”®ï¼šæ—‹è½¬è§†è§’</small><br>
                <small>é¼ æ ‡å³é”®ï¼šç§»åŠ¨ä½ç½®</small><br>
                <small>æ»šè½®ï¼šç¼©æ”¾è§†é‡</small>
            </div>
        </div>
        
        <div id="info">
            ç‰©ç†æ–¹å—æ•°é‡: <span id="blockCount">0</span><br>
            æ€§èƒ½ FPS: <span id="fpsCounter">0</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, world;
        let blocks = [];
        let particles = [];
        let controls, raycaster, mouse;
        let explosionPerformed = false;
        let cameraMode = 0;
        let clock = new THREE.Clock();
        let fps = 0;
        
        // ç‰©ç†å‚æ•°
        const PHYSICS_PARAMS = {
            friction: 0.85,
            restitution: 0.05,
            density: 1
        };
        
        // å»ºç­‘å‚æ•°
        const BUILDING_PARAMS = {
            radius: 20,
            height: 60,
            blocksPerLayer: 20,
            blockSize: 2
        };
        
        // åˆå§‹åŒ–
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 80);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // åˆå§‹åŒ–ç‰©ç†ä¸–ç•Œ
            initPhysics();
            
            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            createGround();
            createBuilding();
            createLights();
            createParticles();
            
            // åˆå§‹åŒ–æ§åˆ¶
            initControls();
            initRaycaster();
            
            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            setupUI();
            
            // å¼€å§‹æ¸²æŸ“
            animate();
            
            // å»¶è¿Ÿå¯ç”¨çˆ†ç‚¸æŒ‰é’®
            setTimeout(() => {
                document.getElementById('explodeBtn').disabled = false;
                document.getElementById('loading').style.display = 'none';
            }, 3000);
        }
        
        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -30, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.allowSleep = true;
        }
        
        function createGround() {
            // è§†è§‰åœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // ç‰©ç†åœ°é¢
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }
        
        function createBuilding() {
            const { radius, height, blocksPerLayer, blockSize } = BUILDING_PARAMS;
            const layerHeight = blockSize;
            const layers = Math.floor(height / layerHeight);
            
            // è®¡ç®—æ¯å±‚æ–¹å—çš„ä½ç½®
            for (let layer = 0; layer < layers; layer++) {
                const y = layer * layerHeight + blockSize / 2;
                // æ¯å±‚é”™ä½50%
                const angleOffset = (layer % 2) * (Math.PI / blocksPerLayer);
                
                for (let i = 0; i < blocksPerLayer; i++) {
                    const angle = (i / blocksPerLayer) * Math.PI * 2 + angleOffset;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    createBlock(x, y, z, angle);
                }
            }
            
            // æ›´æ–°æ–¹å—è®¡æ•°
            document.getElementById('blockCount').textContent = blocks.length;
            
            // è®©ç‰©ç†ä¸–ç•Œç¨³å®šå‡ æ­¥
            for (let i = 0; i < 100; i++) {
                world.step(1/60);
            }
            
            // è®¾ç½®æ‰€æœ‰æ–¹å—ä¸ºç¡çœ çŠ¶æ€
            blocks.forEach(block => {
                block.body.sleep();
            });
        }
        
        function createBlock(x, y, z, angle) {
            // è§†è§‰æ–¹å—
            const geometry = new THREE.BoxGeometry(
                BUILDING_PARAMS.blockSize, 
                BUILDING_PARAMS.blockSize, 
                BUILDING_PARAMS.blockSize
            );
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xF5DEB3,
                transparent: true,
                opacity: 0.95
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            // ç‰©ç†æ–¹å—
            const shape = new CANNON.Box(new CANNON.Vec3(
                BUILDING_PARAMS.blockSize / 2,
                BUILDING_PARAMS.blockSize / 2,
                BUILDING_PARAMS.blockSize / 2
            ));
            
            const body = new CANNON.Body({
                mass: PHYSICS_PARAMS.density,
                position: new CANNON.Vec3(x, y, z),
                sleepSpeedLimit: 0.1,
                sleepTimeLimit: 0.5
            });
            
            body.addShape(shape);
            body.linearDamping = 0.95;
            body.angularDamping = 0.95;
            
            // è®¾ç½®ææ–™å±æ€§
            const material = new CANNON.Material();
            material.friction = PHYSICS_PARAMS.friction;
            material.restitution = PHYSICS_PARAMS.restitution;
            body.material = material;
            
            world.addBody(body);
            
            blocks.push({ mesh, body });
        }
        
        function createLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // è¡¥å……å…‰æº
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-50, 50, -50);
            scene.add(backLight);
        }
        
        function createParticles() {
            // ç²’å­ç³»ç»Ÿå°†åœ¨çˆ†ç‚¸æ—¶åˆ›å»º
        }
        
        function initControls() {
            controls = {
                mouseDown: false,
                mouseButton: -1,
                lastX: 0,
                lastY: 0,
                theta: Math.PI / 4,
                phi: Math.PI / 6,
                radius: 80,
                target: new THREE.Vector3(0, 30, 0)
            };
        }
        
        function initRaycaster() {
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }
        
        function performExplosion() {
            if (explosionPerformed) return;
            
            explosionPerformed = true;
            document.getElementById('explodeBtn').disabled = true;
            
            // æ‰¾åˆ°ç¬¬1å±‚æœ€å³ä¾§çš„æ–¹å—
            let firstLayerBlocks = blocks.filter(block => block.body.position.y < 5);
            let rightmostBlock = firstLayerBlocks.reduce((rightmost, block) => 
                block.body.position.x > rightmost.body.position.x ? block : rightmost
            , firstLayerBlocks[0]);
            
            // çˆ†ç‚¸ç‚¹
            const explosionPoint = rightmostBlock.body.position;
            const explosionRadius = 2;
            const explosionForce = 5;
            
            // å”¤é†’æ‰€æœ‰æ–¹å—
            blocks.forEach(block => {
                block.body.wakeUp();
            });
            
            // å¯¹èŒƒå›´å†…çš„æ–¹å—æ–½åŠ åŠ›
            blocks.forEach(block => {
                const distance = block.body.position.distanceTo(explosionPoint);
                if (distance <= explosionRadius) {
                    const force = new CANNON.Vec3();
                    force.copy(block.body.position);
                    force.vsub(explosionPoint, force);
                    force.normalize();
                    force.scale(explosionForce * (1 - distance / explosionRadius), force);
                    force.y += 2; // å‘ä¸Šçš„åŠ›
                    block.body.applyImpulse(force, block.body.position);
                }
            });
            
            // åˆ›å»ºçˆ†ç‚¸ç²’å­æ•ˆæœ
            createExplosionEffects(explosionPoint);
            
            // ç¬é—´å¢å¼ºå…‰ç…§
            enhanceLighting();
        }
        
        function createExplosionEffects(position) {
            // åˆ›å»ºçƒŸé›¾å’Œç°å°˜ç²’å­
            for (let i = 0; i < 200; i++) {
                setTimeout(() => {
                    createParticle(
                        position.x + (Math.random() - 0.5) * 5,
                        position.y + Math.random() * 10,
                        position.z + (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 2,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2 + 1,
                        0.5
                    );
                }, i * 10);
            }
        }
        
        function createParticle(x, y, z, vx, vy, vz, size, life) {
            const geometry = new THREE.SphereGeometry(size, 4, 4);
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x888888 : 0x666666,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            
            const particle = {
                mesh: mesh,
                velocity: new THREE.Vector3(vx, vy, vz),
                life: life,
                maxLife: life,
                size: size
            };
            
            particles.push(particle);
        }
        
        function enhanceLighting() {
            // åˆ›å»ºä¸´æ—¶çš„çˆ†ç‚¸å…‰
            const explosionLight = new THREE.PointLight(0xff4400, 2, 100);
            explosionLight.position.set(20, 5, 0);
            scene.add(explosionLight);
            
            // 2ç§’åç§»é™¤
            setTimeout(() => {
                scene.remove(explosionLight);
            }, 2000);
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // æ›´æ–°ä½ç½®
                particle.mesh.position.add(
                    particle.velocity.clone().multiplyScalar(deltaTime)
                );
                
                // åº”ç”¨é‡åŠ›
                particle.velocity.y -= 9.8 * deltaTime;
                
                // å‡å°‘ç”Ÿå‘½å‘¨æœŸ
                particle.life -= deltaTime;
                
                // æ›´æ–°é€æ˜åº¦
                particle.mesh.material.opacity = particle.life / particle.maxLife * 0.8;
                
                // å¦‚æœç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œç§»é™¤ç²’å­
                if (particle.life <= 0) {
                    scene.remove(particle.mesh);
                    particles.splice(i, 1);
                }
            }
        }
        
        function resetScene() {
            // ç§»é™¤æ‰€æœ‰æ–¹å—
            blocks.forEach(block => {
                scene.remove(block.mesh);
                world.remove(block.body);
            });
            blocks = [];
            
            // ç§»é™¤æ‰€æœ‰ç²’å­
            particles.forEach(particle => {
                scene.remove(particle.mesh);
            });
            particles = [];
            
            // é‡æ–°åˆ›å»ºå»ºç­‘
            createBuilding();
            
            // é‡ç½®çŠ¶æ€
            explosionPerformed = false;
            document.getElementById('explodeBtn').disabled = false;
            
            // é‡ç½®ç›¸æœº
            cameraMode = 0;
            updateCamera();
        }
        
        function switchCamera() {
            cameraMode = (cameraMode + 1) % 3;
            updateCamera();
        }
        
        function updateCamera() {
            const time = Date.now() * 0.001;
            
            switch (cameraMode) {
                case 0: // é»˜è®¤è§†è§’
                    controls.radius = 80;
                    controls.theta = Math.PI / 4;
                    controls.phi = Math.PI / 6;
                    controls.target.set(0, 30, 0);
                    break;
                case 1: // ä¿¯è§†è§†è§’
                    controls.radius = 100;
                    controls.theta = 0;
                    controls.phi = 0.1;
                    controls.target.set(0, 40, 0);
                    break;
                case 2: // è·Ÿè¸ªè§†è§’
                    controls.radius = 50;
                    controls.theta = time * 0.5;
                    controls.phi = Math.PI / 4;
                    controls.target.set(0, 30, 0);
                    break;
            }
        }
        
        function updateCameraPosition() {
            const x = controls.target.x + controls.radius * Math.sin(controls.phi) * Math.cos(controls.theta);
            const y = controls.target.y + controls.radius * Math.cos(controls.phi);
            const z = controls.target.z + controls.radius * Math.sin(controls.phi) * Math.sin(controls.theta);
            
            camera.position.set(x, y, z);
            camera.lookAt(controls.target);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function setupUI() {
            document.getElementById('explodeBtn').addEventListener('click', performExplosion);
            document.getElementById('resetBtn').addEventListener('click', resetScene);
            document.getElementById('cameraBtn').addEventListener('click', switchCamera);
            
            // é¼ æ ‡æ§åˆ¶
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }
        
        function onMouseDown(event) {
            event.preventDefault();
            controls.mouseDown = true;
            controls.mouseButton = event.button;
            controls.lastX = event.clientX;
            controls.lastY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!controls.mouseDown) return;
            
            const deltaX = event.clientX - controls.lastX;
            const deltaY = event.clientY - controls.lastY;
            
            if (controls.mouseButton === 0) { // å·¦é”® - æ—‹è½¬
                controls.theta -= deltaX * 0.01;
                controls.phi += deltaY * 0.01;
                controls.phi = Math.max(0.1, Math.min(Math.PI - 0.1, controls.phi));
            } else if (controls.mouseButton === 2) { // å³é”® - ç§»åŠ¨ç›®æ ‡
                const scale = controls.radius * 0.01;
                controls.target.x -= deltaX * scale * Math.cos(controls.theta);
                controls.target.z -= deltaX * scale * Math.sin(controls.theta);
                controls.target.y += deltaY * scale;
            }
            
            controls.lastX = event.clientX;
            controls.lastY = event.clientY;
        }
        
        function onMouseUp() {
            controls.mouseDown = false;
        }
        
        function onMouseWheel(event) {
            controls.radius += event.deltaY * 0.1;
            controls.radius = Math.max(10, Math.min(200, controls.radius));
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            
            // æ›´æ–°ç‰©ç†ä¸–ç•Œ
            world.step(1/60, deltaTime, 3);
            
            // æ›´æ–°æ–¹å—ä½ç½®
            blocks.forEach(block => {
                block.mesh.position.copy(block.body.position);
                block.mesh.quaternion.copy(block.body.quaternion);
            });
            
            // æ›´æ–°ç²’å­
            updateParticles(deltaTime);
            
            // æ›´æ–°ç›¸æœº
            updateCameraPosition();
            
            // æ›´æ–°FPS
            fps = 0.9 * fps + 0.1 * (1 / deltaTime);
            document.getElementById('fpsCounter').textContent = Math.round(fps);
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }
        
        // å¯åŠ¨åº”ç”¨
        window.addEventListener('load', init);
    </script>
</body>
</html>


```

è¿™ä¸ª3Då»ºç­‘æ‹†é™¤æ¼”ç¤ºåŒ…å«ä»¥ä¸‹ç‰¹æ€§ï¼š

## ä¸»è¦åŠŸèƒ½ï¼š
1. **çœŸå®ç‰©ç†ç³»ç»Ÿ** - ä½¿ç”¨Cannon.jsç‰©ç†å¼•æ“ï¼ŒåŒ…å«é‡åŠ›ã€æ‘©æ“¦åŠ›ã€ç¢°æ’æ£€æµ‹
2. **ç²¾ç¡®å»ºç­‘ç»“æ„** - åœ†å½¢é«˜å±‚å»ºç­‘ï¼Œæ¯å±‚20ä¸ªæ–¹å—ï¼Œé”™ä½æ’åˆ—å¢å¼ºç¨³å®šæ€§
3. **å®šå‘çˆ†ç ´** - åœ¨å»ºç­‘åº•å±‚å³ä¾§å¼•çˆ†ï¼Œäº§ç”Ÿå†²å‡»æ³¢æ•ˆæœ
4. **éœ‡æ’¼è§†è§‰æ•ˆæœ** - ç²’å­çƒŸé›¾ç³»ç»Ÿã€åŠ¨æ€å…‰ç…§ã€ç¯å¢ƒé›¾åŒ–
5. **å®Œæ•´äº¤äº’æ§åˆ¶** - é¼ æ ‡æ§åˆ¶è§†è§’ã€æ»šè½®ç¼©æ”¾ã€å¤šç›¸æœºæ¨¡å¼

## æŠ€æœ¯äº®ç‚¹ï¼š
- æ–¹å—åˆå§‹æ—¶å¤„äºç‰©ç†ç¡çœ çŠ¶æ€ï¼Œç¡®ä¿å»ºç­‘å®Œå…¨ç¨³å®š
- çˆ†ç‚¸æ—¶å”¤é†’æ‰€æœ‰æ–¹å—å¹¶æ–½åŠ çœŸå®çš„ç‰©ç†åŠ›
- é«˜æ‘©æ“¦ä½å¼¹æ€§ææ–™æ¨¡æ‹Ÿç ‚æµ†ç²˜åˆæ•ˆæœ
- å®æ—¶ç²’å­ç³»ç»Ÿåˆ›å»ºçƒŸé›¾å’Œç°å°˜æ•ˆæœ
- å“åº”å¼è®¾è®¡é€‚é…ä¸åŒå±å¹•å°ºå¯¸

## æ“ä½œè¯´æ˜ï¼š
- ç‚¹å‡»"ğŸ’¥ å¼•çˆ†å»ºç­‘"æŒ‰é’®å¼€å§‹æ‹†é™¤æ¼”ç¤º
- "ğŸ”„ é‡ç½®åœºæ™¯"å¯é‡æ–°ç”Ÿæˆå»ºç­‘
- "ğŸ“±åˆ‡æ¢è§†è§’"åœ¨ä¸‰ç§ç›¸æœºæ¨¡å¼é—´åˆ‡æ¢
- é¼ æ ‡å·¦é”®æ‹–æ‹½æ—‹è½¬è§†è§’
- é¼ æ ‡å³é”®æ‹–æ‹½ç§»åŠ¨è§‚å¯Ÿç‚¹
- æ»šè½®æ§åˆ¶æ‘„åƒæœºè·ç¦»

æµè§ˆå™¨æ‰“å¼€å³å¯ä½“éªŒè¿™ä¸ªéœ‡æ’¼çš„3Då»ºç­‘æ‹†é™¤æ•ˆæœï¼