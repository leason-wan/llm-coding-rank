我将为您创建一个震撼的3D建筑拆除演示。这个项目将包含物理引擎、粒子系统和完整的交互控制。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>震撼3D建筑拆除演示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #explodeBtn {
            background: linear-gradient(45deg, #ff1744, #d50000);
            font-size: 16px;
            padding: 15px 30px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 23, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0); }
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">正在构建建筑物...</div>
        
        <div id="controls">
            <div class="control-group">
                <button id="explodeBtn" disabled>💥 引爆建筑</button>
            </div>
            <div class="control-group">
                <button id="resetBtn">🔄 重置场景</button>
                <button id="cameraBtn">📱切换视角</button>
            </div>
            <div class="control-group">
                <small>鼠标左键：旋转视角</small><br>
                <small>鼠标右键：移动位置</small><br>
                <small>滚轮：缩放视野</small>
            </div>
        </div>
        
        <div id="info">
            物理方块数量: <span id="blockCount">0</span><br>
            性能 FPS: <span id="fpsCounter">0</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <script>
        // 全局变量
        let scene, camera, renderer, world;
        let blocks = [];
        let particles = [];
        let controls, raycaster, mouse;
        let explosionPerformed = false;
        let cameraMode = 0;
        let clock = new THREE.Clock();
        let fps = 0;
        
        // 物理参数
        const PHYSICS_PARAMS = {
            friction: 0.85,
            restitution: 0.05,
            density: 1
        };
        
        // 建筑参数
        const BUILDING_PARAMS = {
            radius: 20,
            height: 60,
            blocksPerLayer: 20,
            blockSize: 2
        };
        
        // 初始化
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 80);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 初始化物理世界
            initPhysics();
            
            // 创建场景元素
            createGround();
            createBuilding();
            createLights();
            createParticles();
            
            // 初始化控制
            initControls();
            initRaycaster();
            
            // 事件监听
            window.addEventListener('resize', onWindowResize);
            setupUI();
            
            // 开始渲染
            animate();
            
            // 延迟启用爆炸按钮
            setTimeout(() => {
                document.getElementById('explodeBtn').disabled = false;
                document.getElementById('loading').style.display = 'none';
            }, 3000);
        }
        
        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -30, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.allowSleep = true;
        }
        
        function createGround() {
            // 视觉地面
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // 物理地面
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }
        
        function createBuilding() {
            const { radius, height, blocksPerLayer, blockSize } = BUILDING_PARAMS;
            const layerHeight = blockSize;
            const layers = Math.floor(height / layerHeight);
            
            // 计算每层方块的位置
            for (let layer = 0; layer < layers; layer++) {
                const y = layer * layerHeight + blockSize / 2;
                // 每层错位50%
                const angleOffset = (layer % 2) * (Math.PI / blocksPerLayer);
                
                for (let i = 0; i < blocksPerLayer; i++) {
                    const angle = (i / blocksPerLayer) * Math.PI * 2 + angleOffset;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    createBlock(x, y, z, angle);
                }
            }
            
            // 更新方块计数
            document.getElementById('blockCount').textContent = blocks.length;
            
            // 让物理世界稳定几步
            for (let i = 0; i < 100; i++) {
                world.step(1/60);
            }
            
            // 设置所有方块为睡眠状态
            blocks.forEach(block => {
                block.body.sleep();
            });
        }
        
        function createBlock(x, y, z, angle) {
            // 视觉方块
            const geometry = new THREE.BoxGeometry(
                BUILDING_PARAMS.blockSize, 
                BUILDING_PARAMS.blockSize, 
                BUILDING_PARAMS.blockSize
            );
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xF5DEB3,
                transparent: true,
                opacity: 0.95
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            
            // 物理方块
            const shape = new CANNON.Box(new CANNON.Vec3(
                BUILDING_PARAMS.blockSize / 2,
                BUILDING_PARAMS.blockSize / 2,
                BUILDING_PARAMS.blockSize / 2
            ));
            
            const body = new CANNON.Body({
                mass: PHYSICS_PARAMS.density,
                position: new CANNON.Vec3(x, y, z),
                sleepSpeedLimit: 0.1,
                sleepTimeLimit: 0.5
            });
            
            body.addShape(shape);
            body.linearDamping = 0.95;
            body.angularDamping = 0.95;
            
            // 设置材料属性
            const material = new CANNON.Material();
            material.friction = PHYSICS_PARAMS.friction;
            material.restitution = PHYSICS_PARAMS.restitution;
            body.material = material;
            
            world.addBody(body);
            
            blocks.push({ mesh, body });
        }
        
        function createLights() {
            // 环境光
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // 主光源
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // 补充光源
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-50, 50, -50);
            scene.add(backLight);
        }
        
        function createParticles() {
            // 粒子系统将在爆炸时创建
        }
        
        function initControls() {
            controls = {
                mouseDown: false,
                mouseButton: -1,
                lastX: 0,
                lastY: 0,
                theta: Math.PI / 4,
                phi: Math.PI / 6,
                radius: 80,
                target: new THREE.Vector3(0, 30, 0)
            };
        }
        
        function initRaycaster() {
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }
        
        function performExplosion() {
            if (explosionPerformed) return;
            
            explosionPerformed = true;
            document.getElementById('explodeBtn').disabled = true;
            
            // 找到第1层最右侧的方块
            let firstLayerBlocks = blocks.filter(block => block.body.position.y < 5);
            let rightmostBlock = firstLayerBlocks.reduce((rightmost, block) => 
                block.body.position.x > rightmost.body.position.x ? block : rightmost
            , firstLayerBlocks[0]);
            
            // 爆炸点
            const explosionPoint = rightmostBlock.body.position;
            const explosionRadius = 2;
            const explosionForce = 5;
            
            // 唤醒所有方块
            blocks.forEach(block => {
                block.body.wakeUp();
            });
            
            // 对范围内的方块施加力
            blocks.forEach(block => {
                const distance = block.body.position.distanceTo(explosionPoint);
                if (distance <= explosionRadius) {
                    const force = new CANNON.Vec3();
                    force.copy(block.body.position);
                    force.vsub(explosionPoint, force);
                    force.normalize();
                    force.scale(explosionForce * (1 - distance / explosionRadius), force);
                    force.y += 2; // 向上的力
                    block.body.applyImpulse(force, block.body.position);
                }
            });
            
            // 创建爆炸粒子效果
            createExplosionEffects(explosionPoint);
            
            // 瞬间增强光照
            enhanceLighting();
        }
        
        function createExplosionEffects(position) {
            // 创建烟雾和灰尘粒子
            for (let i = 0; i < 200; i++) {
                setTimeout(() => {
                    createParticle(
                        position.x + (Math.random() - 0.5) * 5,
                        position.y + Math.random() * 10,
                        position.z + (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 2,
                        Math.random() * 3,
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2 + 1,
                        0.5
                    );
                }, i * 10);
            }
        }
        
        function createParticle(x, y, z, vx, vy, vz, size, life) {
            const geometry = new THREE.SphereGeometry(size, 4, 4);
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x888888 : 0x666666,
                transparent: true,
                opacity: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            
            const particle = {
                mesh: mesh,
                velocity: new THREE.Vector3(vx, vy, vz),
                life: life,
                maxLife: life,
                size: size
            };
            
            particles.push(particle);
        }
        
        function enhanceLighting() {
            // 创建临时的爆炸光
            const explosionLight = new THREE.PointLight(0xff4400, 2, 100);
            explosionLight.position.set(20, 5, 0);
            scene.add(explosionLight);
            
            // 2秒后移除
            setTimeout(() => {
                scene.remove(explosionLight);
            }, 2000);
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // 更新位置
                particle.mesh.position.add(
                    particle.velocity.clone().multiplyScalar(deltaTime)
                );
                
                // 应用重力
                particle.velocity.y -= 9.8 * deltaTime;
                
                // 减少生命周期
                particle.life -= deltaTime;
                
                // 更新透明度
                particle.mesh.material.opacity = particle.life / particle.maxLife * 0.8;
                
                // 如果生命周期结束，移除粒子
                if (particle.life <= 0) {
                    scene.remove(particle.mesh);
                    particles.splice(i, 1);
                }
            }
        }
        
        function resetScene() {
            // 移除所有方块
            blocks.forEach(block => {
                scene.remove(block.mesh);
                world.remove(block.body);
            });
            blocks = [];
            
            // 移除所有粒子
            particles.forEach(particle => {
                scene.remove(particle.mesh);
            });
            particles = [];
            
            // 重新创建建筑
            createBuilding();
            
            // 重置状态
            explosionPerformed = false;
            document.getElementById('explodeBtn').disabled = false;
            
            // 重置相机
            cameraMode = 0;
            updateCamera();
        }
        
        function switchCamera() {
            cameraMode = (cameraMode + 1) % 3;
            updateCamera();
        }
        
        function updateCamera() {
            const time = Date.now() * 0.001;
            
            switch (cameraMode) {
                case 0: // 默认视角
                    controls.radius = 80;
                    controls.theta = Math.PI / 4;
                    controls.phi = Math.PI / 6;
                    controls.target.set(0, 30, 0);
                    break;
                case 1: // 俯视视角
                    controls.radius = 100;
                    controls.theta = 0;
                    controls.phi = 0.1;
                    controls.target.set(0, 40, 0);
                    break;
                case 2: // 跟踪视角
                    controls.radius = 50;
                    controls.theta = time * 0.5;
                    controls.phi = Math.PI / 4;
                    controls.target.set(0, 30, 0);
                    break;
            }
        }
        
        function updateCameraPosition() {
            const x = controls.target.x + controls.radius * Math.sin(controls.phi) * Math.cos(controls.theta);
            const y = controls.target.y + controls.radius * Math.cos(controls.phi);
            const z = controls.target.z + controls.radius * Math.sin(controls.phi) * Math.sin(controls.theta);
            
            camera.position.set(x, y, z);
            camera.lookAt(controls.target);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function setupUI() {
            document.getElementById('explodeBtn').addEventListener('click', performExplosion);
            document.getElementById('resetBtn').addEventListener('click', resetScene);
            document.getElementById('cameraBtn').addEventListener('click', switchCamera);
            
            // 鼠标控制
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onMouseWheel);
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }
        
        function onMouseDown(event) {
            event.preventDefault();
            controls.mouseDown = true;
            controls.mouseButton = event.button;
            controls.lastX = event.clientX;
            controls.lastY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!controls.mouseDown) return;
            
            const deltaX = event.clientX - controls.lastX;
            const deltaY = event.clientY - controls.lastY;
            
            if (controls.mouseButton === 0) { // 左键 - 旋转
                controls.theta -= deltaX * 0.01;
                controls.phi += deltaY * 0.01;
                controls.phi = Math.max(0.1, Math.min(Math.PI - 0.1, controls.phi));
            } else if (controls.mouseButton === 2) { // 右键 - 移动目标
                const scale = controls.radius * 0.01;
                controls.target.x -= deltaX * scale * Math.cos(controls.theta);
                controls.target.z -= deltaX * scale * Math.sin(controls.theta);
                controls.target.y += deltaY * scale;
            }
            
            controls.lastX = event.clientX;
            controls.lastY = event.clientY;
        }
        
        function onMouseUp() {
            controls.mouseDown = false;
        }
        
        function onMouseWheel(event) {
            controls.radius += event.deltaY * 0.1;
            controls.radius = Math.max(10, Math.min(200, controls.radius));
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            
            // 更新物理世界
            world.step(1/60, deltaTime, 3);
            
            // 更新方块位置
            blocks.forEach(block => {
                block.mesh.position.copy(block.body.position);
                block.mesh.quaternion.copy(block.body.quaternion);
            });
            
            // 更新粒子
            updateParticles(deltaTime);
            
            // 更新相机
            updateCameraPosition();
            
            // 更新FPS
            fps = 0.9 * fps + 0.1 * (1 / deltaTime);
            document.getElementById('fpsCounter').textContent = Math.round(fps);
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 启动应用
        window.addEventListener('load', init);
    </script>
</body>
</html>


```

这个3D建筑拆除演示包含以下特性：

## 主要功能：
1. **真实物理系统** - 使用Cannon.js物理引擎，包含重力、摩擦力、碰撞检测
2. **精确建筑结构** - 圆形高层建筑，每层20个方块，错位排列增强稳定性
3. **定向爆破** - 在建筑底层右侧引爆，产生冲击波效果
4. **震撼视觉效果** - 粒子烟雾系统、动态光照、环境雾化
5. **完整交互控制** - 鼠标控制视角、滚轮缩放、多相机模式

## 技术亮点：
- 方块初始时处于物理睡眠状态，确保建筑完全稳定
- 爆炸时唤醒所有方块并施加真实的物理力
- 高摩擦低弹性材料模拟砂浆粘合效果
- 实时粒子系统创建烟雾和灰尘效果
- 响应式设计适配不同屏幕尺寸

## 操作说明：
- 点击"💥 引爆建筑"按钮开始拆除演示
- "🔄 重置场景"可重新生成建筑
- "📱切换视角"在三种相机模式间切换
- 鼠标左键拖拽旋转视角
- 鼠标右键拖拽移动观察点
- 滚轮控制摄像机距离

浏览器打开即可体验这个震撼的3D建筑拆除效果！