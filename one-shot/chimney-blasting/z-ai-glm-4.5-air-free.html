
我将为您创建一个震撼的3D建筑拆除演示。这个演示将使用Three.js和Cannon.js物理引擎来实现逼真的建筑爆破效果。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D建筑拆除演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-title {
            color: #fff;
            font-size: 14px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px 0;
            width: 100%;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.destroy {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            animation: pulse 2s infinite;
        }
        
        button.reset {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(245, 87, 108, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(245, 87, 108, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(245, 87, 108, 0);
            }
        }
        
        #camera-controls {
            font-size: 12px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>正在加载场景...</div>
        </div>
    </div>
    
    <div id="ui" style="display: none;">
        <div class="control-group">
            <div class="control-title">爆破控制</div>
            <button id="explode-btn" class="destroy">🎆 实施定向爆破</button>
            <button id="reset-btn" class="reset">🔄 重置场景</button>
        </div>
        
        <div class="control-group">
            <div class="control-title">相机控制</div>
            <div id="camera-controls">
                🖱️ 左键拖动：旋转视角<br>
                🖱️ 右键拖动：平移视角<br>
                🖱️ 滚轮：缩放视角<br>
                💡 点击按钮切换视角
            </div>
            <button id="camera-view-btn">📷 切换视角</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    
    <script>
        // 全局变量
        let scene, camera, renderer;
        let world;
        let buildingBlocks = [];
        let buildingBodies = [];
        let particles = [];
        let dustParticles = [];
        let isExploded = false;
        let explosionLight = null;
        let ambientLight, directionalLight;
        
        // 相机控制变量
        let cameraRadius = 150;
        let cameraTheta = 0;
        let cameraPhi = Math.PI / 4;
        let isDragging = false;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let mouseButton = 0;
        
        // 初始化场景
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 300);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(100, 50, 100);
            
            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 创建物理世界
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.defaultContactMaterial.contactEquationStiffness = 1e9;
            world.defaultContactMaterial.contactEquationRelaxation = 4;
            
            // 创建光照
            createLights();
            
            // 创建地面
            createGround();
            
            // 创建建筑
            createBuilding();
            
            // 创建粒子系统
            createParticleSystem();
            
            // 添加事件监听器
            addEventListeners();
            
            // 隐藏加载界面
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            
            // 开始渲染循环
            animate();
        }
        
        function createLights() {
            // 环境光
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            // 主方向光
            directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
        }
        
        function createGround() {
            // Three.js 地面
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.8,
                metalness: 0.2
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            // Cannon.js 地面
            const groundShape = new CANNON.Box(new CANNON.Vec3(40, 40, 1));
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                position: new CANNON.Vec3(0, -0.5, 0)
            });
            world.add(groundBody);
        }
        
        function createBuilding() {
            const blockWidth = 2;
            const blockHeight = 2;
            const blockDepth = 2;
            const radius = 20;
            const circumference = radius * 2 * Math.PI;
            const blocksPerLayer = 20;
            const layers = 60;
            
            // 清空之前的建筑
            buildingBlocks = [];
            buildingBodies = [];
            
            // 创建砖块的几何体和材质
            const blockGeometry = new THREE.BoxGeometry(blockWidth, blockHeight, blockDepth);
            const blockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD2B48C,
                roughness: 0.9,
                metalness: 0.1
            });
            
            // 创建接触材料
            const blockBlockMaterial = new CANNON.ContactMaterial(
                new CANNON.Material({ friction: 0.9, restitution: 0.03 }),
                new CANNON.Material({ friction: 0.9, restitution: 0.03 }),
                {
                    friction: 0.9,
                    restitution: 0.03,
                    contactEquationStiffness: 1e9,
                    contactEquationRelaxation: 4
                }
            );
            
            const blockGroundMaterial = new CANNON.ContactMaterial(
                new CANNON.Material({ friction: 0.9, restitution: 0.03 }),
                new CANNON.Material({ friction: 0.7, restitution: 0.3 }),
                {
                    friction: 0.7,
                    restitution: 0.3
                }
            );
            
            world.addContactMaterial(blockBlockMaterial);
            world.addContactMaterial(blockGroundMaterial);
            
            // 创建建筑每一层
            for (let layer = 0; layer < layers; layer++) {
                const isFirstLayer = layer === 0;
                const isSecondLayer = layer === 1;
                
                for (let i = 0; i < blocksPerLayer; i++) {
                    const angle = (i / blocksPerLayer) * 2 * Math.PI;
                    const nextAngle = ((i + 1) / blocksPerLayer) * 2 * Math.PI;
                    
                    // 砖块错开50%排列
                    const offset = isFirstLayer ? 0 : 1.0 * (i % 2) * 2;
                    let angleOffset = angle + (offset / radius);
                    const x = Math.cos(angleOffset) * radius;
                    const z = Math.sin(angleOffset) * radius;
                    
                    // Three.js 网格
                    const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial);
                    blockMesh.position.set(x, layer * blockHeight, z);
                    blockMesh.castShadow = true;
                    blockMesh.receiveShadow = true;
                    scene.add(blockMesh);
                    buildingBlocks.push(blockMesh);
                    
                    // Cannon.js 刚体
                    const blockShape = new CANNON.Box(new CANNON.Vec3(blockWidth/2, blockHeight/2, blockDepth/2));
                    const blockBody = new CANNON.Body({
                        mass: isFirstLayer ? 0 : 1,
                        shape: blockShape,
                        position: new CANNON.Vec3(x, layer * blockHeight - blockHeight/2, z),
                        material: new CANNON.Material({ friction: 0.9, restitution: 0.03 })
                    });
                    
                    // 第一层设置为静止状态
                    if (isFirstLayer) {
                        blockBody.type = CANNON.Body.STATIC;
                    }
                    
                    world.add(blockBody);
                    buildingBodies.push(blockBody);
                    
                    // 设置爆炸位置（第一层最右侧）
                    if (isFirstLayer && i === blocksPerLayer - 1) {
                        explosionPosition = blockBody.position.clone();
                    }
                }
            }
            
            // 运行几个物理步骤来稳定建筑
            for (let i = 0; i < 10; i++) {
                world.step(1/60);
            }
            
            // 让所有砖块进入睡眠状态，直到被爆炸唤醒
            buildingBodies.forEach(body => {
                if (body.type !== CANNON.Body.STATIC) {
                    body.sleep();
                }
            });
        }
        
        let explosionPosition = null;
        
        function createParticleSystem() {
            // 烟雾粒子
            const smokeGeometry = new THREE.BufferGeometry();
            const smokeCount = 1000;
            const smokePositions = new Float32Array(smokeCount * 3);
            const smokeColors = new Float32Array(smokeCount * 3);
            
            for (let i = 0; i < smokeCount * 3; i += 3) {
                smokePositions[i] = 0;
                smokePositions[i + 1] = 0;
                smokePositions[i + 2] = 0;
                
                smokeColors[i] = 0.5;
                smokeColors[i + 1] = 0.5;
                smokeColors[i + 2] = 0.5;
            }
            
            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
            smokeGeometry.setAttribute('color', new THREE.BufferAttribute(smokeColors, 3));
            
            const smokeMaterial = new THREE.PointsMaterial({
                size: 5,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0
            });
            
            const smokeParticles = new THREE.Points(smokeGeometry, smokeMaterial);
            scene.add(smokeParticles);
            particles.push(smokeParticles);
            
            // 灰尘粒子
            const dustGeometry = new THREE.BufferGeometry();
            const dustCount = 500;
            const dustPositions = new Float32Array(dustCount * 3);
            const dustVelocities = [];
            
            for (let i = 0; i < dustCount * 3; i += 3) {
                dustPositions[i] = -10 + Math.random() * 20;
                dustPositions[i + 1] = 0;
                dustPositions[i + 2] = -10 + Math.random() * 20;
                
                dustVelocities.push({
                    x: (Math.random() - 0.5) * 0.1,
                    y: Math.random() * 0.2,
                    z: (Math.random() - 0.5) * 0.1
                });
            }
            
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            
            const dustMaterial = new THREE.PointsMaterial({
                size: 2,
                color: 0x8B7355,
                blending: THREE.MultiplyBlending,
                transparent: true,
                opacity: 0
            });
            
            const dustParticleSystem = new THREE.Points(dustGeometry, dustMaterial);
            dustParticleSystem.userData.velocities = dustVelocities;
            scene.add(dustParticleSystem);
            dustParticles.push(dustParticleSystem);
        }
        
        function explodeBuilding() {
            if (isExploded || !explosionPosition) return;
            
            isExploded = true;
            
            // 创建爆炸效果
            const explosionEffect = createExplosionEffect(explosionPosition.x, explosionPosition.y + 1, explosionPosition.z);
            scene.add(explosionEffect);
            
            // 创建爆炸光源
            explosionLight = new THREE.PointLight(0xff7700, 5, 50);
            explosionLight.position.set(explosionPosition.x, explosionPosition.y + 5, explosionPosition.z);
            scene.add(explosionLight);
            
            // 增强环境光
            ambientLight.intensity = 1;
            directionalLight.intensity = 2;
            
            // 计算爆炸影响
            const explosionRadius = 20;
            const explosionForce = 5000;
            
            buildingBodies.forEach((body, index) => {
                const distance = body.position.distanceTo(explosionPosition);
                
                if (distance < explosionRadius) {
                    // 唤醒身体
                    body.wakeUp();
                    
                    // 计算爆炸力
                    const direction = new CANNON.Vec3();
                    body.position.vsub(explosionPosition, direction);
                    direction.normalize();
                    
                    const forceMagnitude = explosionForce * (1 - distance / explosionRadius);
                    const force = direction.scale(forceMagnitude);
                    
                    // 添加一些随机性
                    force.x += (Math.random() - 0.5) * 1000;
                    force.y += Math.random() * 500;
                    force.z += (Math.random() - 0.5) * 1000;
                    
                    body.applyImpulse(force, body.position);
                    
                    // 如果是第一层的砖块，给它一个更大的冲击力来破坏整个结构
                    if (index < 20) {
                        body.applyImpulse(new CANNON.Vec3(0, 2000, 0), body.position);
                    }
                }
            });
            
            // 开始粒子效果
            startParticleEffects();
            
            // 3秒后移除爆炸光源
            setTimeout(() => {
                scene.remove(explosionLight);
                explosionLight = null;
                ambientLight.intensity = 0.5;
                directionalLight.intensity = 1;
            }, 3000);
            
            // 5秒后清理爆炸效果
            setTimeout(() => {
                scene.remove(explosionEffect);
            }, 5000);
        }
        
        function createExplosionEffect(x, y, z) {
            const explosionGeometry = new THREE.SphereGeometry(2, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8
            });
            
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.set(x, y, z);
            
            // 爆炸动画
            let scale = 1;
            const animateExplosion = () => {
                scale += 0.3;
                explosion.scale.set(scale, scale, scale);
                explosionMaterial.opacity -= 0.02;
                
                if (explosionMaterial.opacity > 0) {
                    requestAnimationFrame(animateExplosion);
                }
            };
            animateExplosion();
            
            return explosion;
        }
        
        function startParticleEffects() {
            // 激活烟雾效果
            particles.forEach(particleSystem => {
                if (particleSystem.material instanceof THREE.PointsMaterial) {
                    particleSystem.material.size = 10;
                    particleSystem.material.opacity = 0.6;
                }
            });
            
            // 激活灰尘效果
            dustParticles.forEach(particleSystem => {
                if (particleSystem instanceof THREE.Points) {
                    particleSystem.material.opacity = 0.4;
                }
            });
        }
        
        function updateParticles() {
            // 更新烟雾粒子
            particles.forEach(particleSystem => {
                if (particleSystem.material instanceof THREE.PointsMaterial && 
                    particleSystem.material.opacity > 0) {
                    
                    const positions = particleSystem.geometry.attributes.position.array;
                    particleSystem.material.opacity -= 0.005;
                    particleSystem.material.size += 0.1;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += 0.5; // 向上飘
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }
            });
            
            // 更新灰尘粒子
            dustParticles.forEach(particleSystem => {
                if (particleSystem instanceof THREE.Points && particleSystem.material.opacity > 0) {
                    const positions = particleSystem.geometry.attributes.position.array;
                    const velocities = particleSystem.userData.velocities;
                    const time = Date.now() * 0.001;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        const velocity = velocities[i / 3];
                        positions[i] += velocity.x * 0.5 + Math.sin(time) * 0.1;
                        positions[i + 1] += velocity.y * 0.5;
                        positions[i + 2] += velocity.z * 0.5 + Math.cos(time) * 0.1;
                    }
                    
                    particleSystem.material.opacity -= 0.003;
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }
            });
        }
        
        function resetScene() {
            isExploded = false;
            
            // 清理现有建筑
            buildingBlocks.forEach(block => scene.remove(block));
            buildingBodies.forEach(body => world.remove(body));
            
            // 创建新建筑
            createBuilding();
            
            // 重置粒子效果
            particles.forEach(particleSystem => {
                if (particleSystem.material instanceof THREE.Points) {
                    particleSystem.material.size = 5;
                    particleSystem.material.opacity = 0;
                }
            });
            
            dustParticles.forEach(particleSystem => {
                if (particleSystem instanceof THREE.Points) {
                    particleSystem.material.opacity = 0;
                }
            });
            
            // 重新设置相机位置
            cameraRadius = 150;
            cameraTheta = 0;
            cameraPhi = Math.PI / 4;
            updateCameraPosition();
            
            // 移除爆炸光源
            if (explosionLight) {
                scene.remove(explosionLight);
                explosionLight = null;
            }
        }
        
        function updateCameraPosition() {
            const x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            const y = cameraRadius * Math.cos(cameraPhi);
            const z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            
            camera.position.set(x, y, z);
            camera.lookAt(0, 30, 0);
        }
        
        function addEventListeners() {
            // 鼠标事件
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('wheel', onMouseWheel, false);
            
            // 按钮事件
            document.getElementById('explode-btn').addEventListener('click', explodeBuilding);
            document.getElementById('reset-btn').addEventListener('click', resetScene);
            document.getElementById('camera-view-btn').addEventListener('click', () => {
                cameraTheta += Math.PI / 3;
                updateCameraPosition();
            });
            
            // 窗口大小调整
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onMouseDown(event) {
            isDragging = true;
            mouseButton = event.button;
            prevMouseX = event.clientX;
            prevMouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!isDragging) return;
            
            const deltaX = event.clientX - prevMouseX;
            const deltaY = event.clientY - prevMouseY;
            
            if (mouseButton === 0) {
                // 左键拖动 - 旋转
                cameraTheta -= deltaX * 0.01;
                cameraPhi -= deltaY * 0.01;
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
            } else if (mouseButton === 2) {
                // 右键拖动 - 平移
                const moveX = deltaX * 0.3;
                const moveY = deltaY * 0.3;
                
                // 根据相机的朝向应用平移
                const right = new THREE.Vector3();
                camera.getWorldDirection(right);
                right.cross(camera.up).normalize();
                
                camera.position.x -= right.x * moveX;
                camera.position.z -= right.z * moveX;
                camera.position.y += moveY;
            }
            
            updateCameraPosition();
            
            prevMouseX = event.clientX;
            prevMouseY = event.clientY;
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onMouseWheel(event) {
            cameraRadius += event.deltaY * 0.1;
            cameraRadius = Math.max(50, Math.min(300, cameraRadius));
            updateCameraPosition();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 防止右键菜单
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新物理世界
            world.step(1/60);
            
            // 同步Three.js meshes和Cannon.js bodies
            buildingBlocks.forEach((block, index) => {
                if (buildingBodies[index]) {
                    block.position.copy(buildingBodies[index].position);
                    block.quaternion.copy(buildingBodies[index].quaternion);
                }
            });
            
            // 更新粒子
            updateParticles();
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        // 初始化应用
        window.addEventListener('load', init);
    </script>
</body>
</html>
```

这个3D建筑拆除演示实现了您要求的所有功能：

## 核心特性：

### 1. **逼真的建筑结构**
- 圆形高层建筑，周长20个砖块，高度60层
- 砖块错排50%增加稳定性
- 米色砖墙材质，紧密贴合无间隙

### 2. **精确的物理模拟**
- 使用Cannon.js物理引擎实现真实物理效果
- 砖块间高摩擦力(0.9)和低弹性(0.03)模拟砂浆粘合
- 支持重力和碰撞检测
- 初始状态为睡眠，保持建筑绝对稳定

### 3. **定向爆破系统**
- 第一层最右侧设置爆炸点
- 点击按钮触发定向爆破
- 爆炸力影响半径20米，强度随距离递减
- 建筑整体倒塌后才散落

### 4. **震撼的视觉效果**
- 爆炸瞬间闪光效果和光增强
- 烟雾和灰尘粒子系统
- 方块飞散、翻滚、碰撞真实效果
- 阴影和光照动态变化

### 5. **直观的交互控制**
- 鼠标左键拖动旋转视角
- 鼠标右键平移视角
- 滚轮缩放焦距
- 一键切换预览角度
- 重置场景按钮

演示会先加载一个60米高的圆形砖石建筑，点击"实施定向爆破"按钮后，建筑会在精确设定的位置爆破，随后按照真实物理规律倒塌，营造出震撼的建筑拆除效果。