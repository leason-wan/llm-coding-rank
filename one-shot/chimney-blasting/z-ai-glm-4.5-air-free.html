
æˆ‘å°†ä¸ºæ‚¨åˆ›å»ºä¸€ä¸ªéœ‡æ’¼çš„3Då»ºç­‘æ‹†é™¤æ¼”ç¤ºã€‚è¿™ä¸ªæ¼”ç¤ºå°†ä½¿ç”¨Three.jså’ŒCannon.jsç‰©ç†å¼•æ“æ¥å®ç°é€¼çœŸçš„å»ºç­‘çˆ†ç ´æ•ˆæœã€‚

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då»ºç­‘æ‹†é™¤æ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-title {
            color: #fff;
            font-size: 14px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px 0;
            width: 100%;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.destroy {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            animation: pulse 2s infinite;
        }
        
        button.reset {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(245, 87, 108, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(245, 87, 108, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(245, 87, 108, 0);
            }
        }
        
        #camera-controls {
            font-size: 12px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>æ­£åœ¨åŠ è½½åœºæ™¯...</div>
        </div>
    </div>
    
    <div id="ui" style="display: none;">
        <div class="control-group">
            <div class="control-title">çˆ†ç ´æ§åˆ¶</div>
            <button id="explode-btn" class="destroy">ğŸ† å®æ–½å®šå‘çˆ†ç ´</button>
            <button id="reset-btn" class="reset">ğŸ”„ é‡ç½®åœºæ™¯</button>
        </div>
        
        <div class="control-group">
            <div class="control-title">ç›¸æœºæ§åˆ¶</div>
            <div id="camera-controls">
                ğŸ–±ï¸ å·¦é”®æ‹–åŠ¨ï¼šæ—‹è½¬è§†è§’<br>
                ğŸ–±ï¸ å³é”®æ‹–åŠ¨ï¼šå¹³ç§»è§†è§’<br>
                ğŸ–±ï¸ æ»šè½®ï¼šç¼©æ”¾è§†è§’<br>
                ğŸ’¡ ç‚¹å‡»æŒ‰é’®åˆ‡æ¢è§†è§’
            </div>
            <button id="camera-view-btn">ğŸ“· åˆ‡æ¢è§†è§’</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let world;
        let buildingBlocks = [];
        let buildingBodies = [];
        let particles = [];
        let dustParticles = [];
        let isExploded = false;
        let explosionLight = null;
        let ambientLight, directionalLight;
        
        // ç›¸æœºæ§åˆ¶å˜é‡
        let cameraRadius = 150;
        let cameraTheta = 0;
        let cameraPhi = Math.PI / 4;
        let isDragging = false;
        let prevMouseX = 0;
        let prevMouseY = 0;
        let mouseButton = 0;
        
        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 100, 300);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(100, 50, 100);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // åˆ›å»ºç‰©ç†ä¸–ç•Œ
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.defaultContactMaterial.contactEquationStiffness = 1e9;
            world.defaultContactMaterial.contactEquationRelaxation = 4;
            
            // åˆ›å»ºå…‰ç…§
            createLights();
            
            // åˆ›å»ºåœ°é¢
            createGround();
            
            // åˆ›å»ºå»ºç­‘
            createBuilding();
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            addEventListeners();
            
            // éšè—åŠ è½½ç•Œé¢
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            
            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }
        
        function createLights() {
            // ç¯å¢ƒå…‰
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            // ä¸»æ–¹å‘å…‰
            directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
        }
        
        function createGround() {
            // Three.js åœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a,
                roughness: 0.8,
                metalness: 0.2
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            // Cannon.js åœ°é¢
            const groundShape = new CANNON.Box(new CANNON.Vec3(40, 40, 1));
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                position: new CANNON.Vec3(0, -0.5, 0)
            });
            world.add(groundBody);
        }
        
        function createBuilding() {
            const blockWidth = 2;
            const blockHeight = 2;
            const blockDepth = 2;
            const radius = 20;
            const circumference = radius * 2 * Math.PI;
            const blocksPerLayer = 20;
            const layers = 60;
            
            // æ¸…ç©ºä¹‹å‰çš„å»ºç­‘
            buildingBlocks = [];
            buildingBodies = [];
            
            // åˆ›å»ºç –å—çš„å‡ ä½•ä½“å’Œæè´¨
            const blockGeometry = new THREE.BoxGeometry(blockWidth, blockHeight, blockDepth);
            const blockMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD2B48C,
                roughness: 0.9,
                metalness: 0.1
            });
            
            // åˆ›å»ºæ¥è§¦ææ–™
            const blockBlockMaterial = new CANNON.ContactMaterial(
                new CANNON.Material({ friction: 0.9, restitution: 0.03 }),
                new CANNON.Material({ friction: 0.9, restitution: 0.03 }),
                {
                    friction: 0.9,
                    restitution: 0.03,
                    contactEquationStiffness: 1e9,
                    contactEquationRelaxation: 4
                }
            );
            
            const blockGroundMaterial = new CANNON.ContactMaterial(
                new CANNON.Material({ friction: 0.9, restitution: 0.03 }),
                new CANNON.Material({ friction: 0.7, restitution: 0.3 }),
                {
                    friction: 0.7,
                    restitution: 0.3
                }
            );
            
            world.addContactMaterial(blockBlockMaterial);
            world.addContactMaterial(blockGroundMaterial);
            
            // åˆ›å»ºå»ºç­‘æ¯ä¸€å±‚
            for (let layer = 0; layer < layers; layer++) {
                const isFirstLayer = layer === 0;
                const isSecondLayer = layer === 1;
                
                for (let i = 0; i < blocksPerLayer; i++) {
                    const angle = (i / blocksPerLayer) * 2 * Math.PI;
                    const nextAngle = ((i + 1) / blocksPerLayer) * 2 * Math.PI;
                    
                    // ç –å—é”™å¼€50%æ’åˆ—
                    const offset = isFirstLayer ? 0 : 1.0 * (i % 2) * 2;
                    let angleOffset = angle + (offset / radius);
                    const x = Math.cos(angleOffset) * radius;
                    const z = Math.sin(angleOffset) * radius;
                    
                    // Three.js ç½‘æ ¼
                    const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial);
                    blockMesh.position.set(x, layer * blockHeight, z);
                    blockMesh.castShadow = true;
                    blockMesh.receiveShadow = true;
                    scene.add(blockMesh);
                    buildingBlocks.push(blockMesh);
                    
                    // Cannon.js åˆšä½“
                    const blockShape = new CANNON.Box(new CANNON.Vec3(blockWidth/2, blockHeight/2, blockDepth/2));
                    const blockBody = new CANNON.Body({
                        mass: isFirstLayer ? 0 : 1,
                        shape: blockShape,
                        position: new CANNON.Vec3(x, layer * blockHeight - blockHeight/2, z),
                        material: new CANNON.Material({ friction: 0.9, restitution: 0.03 })
                    });
                    
                    // ç¬¬ä¸€å±‚è®¾ç½®ä¸ºé™æ­¢çŠ¶æ€
                    if (isFirstLayer) {
                        blockBody.type = CANNON.Body.STATIC;
                    }
                    
                    world.add(blockBody);
                    buildingBodies.push(blockBody);
                    
                    // è®¾ç½®çˆ†ç‚¸ä½ç½®ï¼ˆç¬¬ä¸€å±‚æœ€å³ä¾§ï¼‰
                    if (isFirstLayer && i === blocksPerLayer - 1) {
                        explosionPosition = blockBody.position.clone();
                    }
                }
            }
            
            // è¿è¡Œå‡ ä¸ªç‰©ç†æ­¥éª¤æ¥ç¨³å®šå»ºç­‘
            for (let i = 0; i < 10; i++) {
                world.step(1/60);
            }
            
            // è®©æ‰€æœ‰ç –å—è¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç›´åˆ°è¢«çˆ†ç‚¸å”¤é†’
            buildingBodies.forEach(body => {
                if (body.type !== CANNON.Body.STATIC) {
                    body.sleep();
                }
            });
        }
        
        let explosionPosition = null;
        
        function createParticleSystem() {
            // çƒŸé›¾ç²’å­
            const smokeGeometry = new THREE.BufferGeometry();
            const smokeCount = 1000;
            const smokePositions = new Float32Array(smokeCount * 3);
            const smokeColors = new Float32Array(smokeCount * 3);
            
            for (let i = 0; i < smokeCount * 3; i += 3) {
                smokePositions[i] = 0;
                smokePositions[i + 1] = 0;
                smokePositions[i + 2] = 0;
                
                smokeColors[i] = 0.5;
                smokeColors[i + 1] = 0.5;
                smokeColors[i + 2] = 0.5;
            }
            
            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
            smokeGeometry.setAttribute('color', new THREE.BufferAttribute(smokeColors, 3));
            
            const smokeMaterial = new THREE.PointsMaterial({
                size: 5,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0
            });
            
            const smokeParticles = new THREE.Points(smokeGeometry, smokeMaterial);
            scene.add(smokeParticles);
            particles.push(smokeParticles);
            
            // ç°å°˜ç²’å­
            const dustGeometry = new THREE.BufferGeometry();
            const dustCount = 500;
            const dustPositions = new Float32Array(dustCount * 3);
            const dustVelocities = [];
            
            for (let i = 0; i < dustCount * 3; i += 3) {
                dustPositions[i] = -10 + Math.random() * 20;
                dustPositions[i + 1] = 0;
                dustPositions[i + 2] = -10 + Math.random() * 20;
                
                dustVelocities.push({
                    x: (Math.random() - 0.5) * 0.1,
                    y: Math.random() * 0.2,
                    z: (Math.random() - 0.5) * 0.1
                });
            }
            
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            
            const dustMaterial = new THREE.PointsMaterial({
                size: 2,
                color: 0x8B7355,
                blending: THREE.MultiplyBlending,
                transparent: true,
                opacity: 0
            });
            
            const dustParticleSystem = new THREE.Points(dustGeometry, dustMaterial);
            dustParticleSystem.userData.velocities = dustVelocities;
            scene.add(dustParticleSystem);
            dustParticles.push(dustParticleSystem);
        }
        
        function explodeBuilding() {
            if (isExploded || !explosionPosition) return;
            
            isExploded = true;
            
            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            const explosionEffect = createExplosionEffect(explosionPosition.x, explosionPosition.y + 1, explosionPosition.z);
            scene.add(explosionEffect);
            
            // åˆ›å»ºçˆ†ç‚¸å…‰æº
            explosionLight = new THREE.PointLight(0xff7700, 5, 50);
            explosionLight.position.set(explosionPosition.x, explosionPosition.y + 5, explosionPosition.z);
            scene.add(explosionLight);
            
            // å¢å¼ºç¯å¢ƒå…‰
            ambientLight.intensity = 1;
            directionalLight.intensity = 2;
            
            // è®¡ç®—çˆ†ç‚¸å½±å“
            const explosionRadius = 20;
            const explosionForce = 5000;
            
            buildingBodies.forEach((body, index) => {
                const distance = body.position.distanceTo(explosionPosition);
                
                if (distance < explosionRadius) {
                    // å”¤é†’èº«ä½“
                    body.wakeUp();
                    
                    // è®¡ç®—çˆ†ç‚¸åŠ›
                    const direction = new CANNON.Vec3();
                    body.position.vsub(explosionPosition, direction);
                    direction.normalize();
                    
                    const forceMagnitude = explosionForce * (1 - distance / explosionRadius);
                    const force = direction.scale(forceMagnitude);
                    
                    // æ·»åŠ ä¸€äº›éšæœºæ€§
                    force.x += (Math.random() - 0.5) * 1000;
                    force.y += Math.random() * 500;
                    force.z += (Math.random() - 0.5) * 1000;
                    
                    body.applyImpulse(force, body.position);
                    
                    // å¦‚æœæ˜¯ç¬¬ä¸€å±‚çš„ç –å—ï¼Œç»™å®ƒä¸€ä¸ªæ›´å¤§çš„å†²å‡»åŠ›æ¥ç ´åæ•´ä¸ªç»“æ„
                    if (index < 20) {
                        body.applyImpulse(new CANNON.Vec3(0, 2000, 0), body.position);
                    }
                }
            });
            
            // å¼€å§‹ç²’å­æ•ˆæœ
            startParticleEffects();
            
            // 3ç§’åç§»é™¤çˆ†ç‚¸å…‰æº
            setTimeout(() => {
                scene.remove(explosionLight);
                explosionLight = null;
                ambientLight.intensity = 0.5;
                directionalLight.intensity = 1;
            }, 3000);
            
            // 5ç§’åæ¸…ç†çˆ†ç‚¸æ•ˆæœ
            setTimeout(() => {
                scene.remove(explosionEffect);
            }, 5000);
        }
        
        function createExplosionEffect(x, y, z) {
            const explosionGeometry = new THREE.SphereGeometry(2, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8
            });
            
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.set(x, y, z);
            
            // çˆ†ç‚¸åŠ¨ç”»
            let scale = 1;
            const animateExplosion = () => {
                scale += 0.3;
                explosion.scale.set(scale, scale, scale);
                explosionMaterial.opacity -= 0.02;
                
                if (explosionMaterial.opacity > 0) {
                    requestAnimationFrame(animateExplosion);
                }
            };
            animateExplosion();
            
            return explosion;
        }
        
        function startParticleEffects() {
            // æ¿€æ´»çƒŸé›¾æ•ˆæœ
            particles.forEach(particleSystem => {
                if (particleSystem.material instanceof THREE.PointsMaterial) {
                    particleSystem.material.size = 10;
                    particleSystem.material.opacity = 0.6;
                }
            });
            
            // æ¿€æ´»ç°å°˜æ•ˆæœ
            dustParticles.forEach(particleSystem => {
                if (particleSystem instanceof THREE.Points) {
                    particleSystem.material.opacity = 0.4;
                }
            });
        }
        
        function updateParticles() {
            // æ›´æ–°çƒŸé›¾ç²’å­
            particles.forEach(particleSystem => {
                if (particleSystem.material instanceof THREE.PointsMaterial && 
                    particleSystem.material.opacity > 0) {
                    
                    const positions = particleSystem.geometry.attributes.position.array;
                    particleSystem.material.opacity -= 0.005;
                    particleSystem.material.size += 0.1;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += 0.5; // å‘ä¸Šé£˜
                    }
                    
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }
            });
            
            // æ›´æ–°ç°å°˜ç²’å­
            dustParticles.forEach(particleSystem => {
                if (particleSystem instanceof THREE.Points && particleSystem.material.opacity > 0) {
                    const positions = particleSystem.geometry.attributes.position.array;
                    const velocities = particleSystem.userData.velocities;
                    const time = Date.now() * 0.001;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        const velocity = velocities[i / 3];
                        positions[i] += velocity.x * 0.5 + Math.sin(time) * 0.1;
                        positions[i + 1] += velocity.y * 0.5;
                        positions[i + 2] += velocity.z * 0.5 + Math.cos(time) * 0.1;
                    }
                    
                    particleSystem.material.opacity -= 0.003;
                    particleSystem.geometry.attributes.position.needsUpdate = true;
                }
            });
        }
        
        function resetScene() {
            isExploded = false;
            
            // æ¸…ç†ç°æœ‰å»ºç­‘
            buildingBlocks.forEach(block => scene.remove(block));
            buildingBodies.forEach(body => world.remove(body));
            
            // åˆ›å»ºæ–°å»ºç­‘
            createBuilding();
            
            // é‡ç½®ç²’å­æ•ˆæœ
            particles.forEach(particleSystem => {
                if (particleSystem.material instanceof THREE.Points) {
                    particleSystem.material.size = 5;
                    particleSystem.material.opacity = 0;
                }
            });
            
            dustParticles.forEach(particleSystem => {
                if (particleSystem instanceof THREE.Points) {
                    particleSystem.material.opacity = 0;
                }
            });
            
            // é‡æ–°è®¾ç½®ç›¸æœºä½ç½®
            cameraRadius = 150;
            cameraTheta = 0;
            cameraPhi = Math.PI / 4;
            updateCameraPosition();
            
            // ç§»é™¤çˆ†ç‚¸å…‰æº
            if (explosionLight) {
                scene.remove(explosionLight);
                explosionLight = null;
            }
        }
        
        function updateCameraPosition() {
            const x = cameraRadius * Math.sin(cameraPhi) * Math.cos(cameraTheta);
            const y = cameraRadius * Math.cos(cameraPhi);
            const z = cameraRadius * Math.sin(cameraPhi) * Math.sin(cameraTheta);
            
            camera.position.set(x, y, z);
            camera.lookAt(0, 30, 0);
        }
        
        function addEventListeners() {
            // é¼ æ ‡äº‹ä»¶
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('wheel', onMouseWheel, false);
            
            // æŒ‰é’®äº‹ä»¶
            document.getElementById('explode-btn').addEventListener('click', explodeBuilding);
            document.getElementById('reset-btn').addEventListener('click', resetScene);
            document.getElementById('camera-view-btn').addEventListener('click', () => {
                cameraTheta += Math.PI / 3;
                updateCameraPosition();
            });
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function onMouseDown(event) {
            isDragging = true;
            mouseButton = event.button;
            prevMouseX = event.clientX;
            prevMouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!isDragging) return;
            
            const deltaX = event.clientX - prevMouseX;
            const deltaY = event.clientY - prevMouseY;
            
            if (mouseButton === 0) {
                // å·¦é”®æ‹–åŠ¨ - æ—‹è½¬
                cameraTheta -= deltaX * 0.01;
                cameraPhi -= deltaY * 0.01;
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
            } else if (mouseButton === 2) {
                // å³é”®æ‹–åŠ¨ - å¹³ç§»
                const moveX = deltaX * 0.3;
                const moveY = deltaY * 0.3;
                
                // æ ¹æ®ç›¸æœºçš„æœå‘åº”ç”¨å¹³ç§»
                const right = new THREE.Vector3();
                camera.getWorldDirection(right);
                right.cross(camera.up).normalize();
                
                camera.position.x -= right.x * moveX;
                camera.position.z -= right.z * moveX;
                camera.position.y += moveY;
            }
            
            updateCameraPosition();
            
            prevMouseX = event.clientX;
            prevMouseY = event.clientY;
        }
        
        function onMouseUp() {
            isDragging = false;
        }
        
        function onMouseWheel(event) {
            cameraRadius += event.deltaY * 0.1;
            cameraRadius = Math.max(50, Math.min(300, cameraRadius));
            updateCameraPosition();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // é˜²æ­¢å³é”®èœå•
        renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç‰©ç†ä¸–ç•Œ
            world.step(1/60);
            
            // åŒæ­¥Three.js mesheså’ŒCannon.js bodies
            buildingBlocks.forEach((block, index) => {
                if (buildingBodies[index]) {
                    block.position.copy(buildingBodies[index].position);
                    block.quaternion.copy(buildingBodies[index].quaternion);
                }
            });
            
            // æ›´æ–°ç²’å­
            updateParticles();
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('load', init);
    </script>
</body>
</html>
```

è¿™ä¸ª3Då»ºç­‘æ‹†é™¤æ¼”ç¤ºå®ç°äº†æ‚¨è¦æ±‚çš„æ‰€æœ‰åŠŸèƒ½ï¼š

## æ ¸å¿ƒç‰¹æ€§ï¼š

### 1. **é€¼çœŸçš„å»ºç­‘ç»“æ„**
- åœ†å½¢é«˜å±‚å»ºç­‘ï¼Œå‘¨é•¿20ä¸ªç –å—ï¼Œé«˜åº¦60å±‚
- ç –å—é”™æ’50%å¢åŠ ç¨³å®šæ€§
- ç±³è‰²ç –å¢™æè´¨ï¼Œç´§å¯†è´´åˆæ— é—´éš™

### 2. **ç²¾ç¡®çš„ç‰©ç†æ¨¡æ‹Ÿ**
- ä½¿ç”¨Cannon.jsç‰©ç†å¼•æ“å®ç°çœŸå®ç‰©ç†æ•ˆæœ
- ç –å—é—´é«˜æ‘©æ“¦åŠ›(0.9)å’Œä½å¼¹æ€§(0.03)æ¨¡æ‹Ÿç ‚æµ†ç²˜åˆ
- æ”¯æŒé‡åŠ›å’Œç¢°æ’æ£€æµ‹
- åˆå§‹çŠ¶æ€ä¸ºç¡çœ ï¼Œä¿æŒå»ºç­‘ç»å¯¹ç¨³å®š

### 3. **å®šå‘çˆ†ç ´ç³»ç»Ÿ**
- ç¬¬ä¸€å±‚æœ€å³ä¾§è®¾ç½®çˆ†ç‚¸ç‚¹
- ç‚¹å‡»æŒ‰é’®è§¦å‘å®šå‘çˆ†ç ´
- çˆ†ç‚¸åŠ›å½±å“åŠå¾„20ç±³ï¼Œå¼ºåº¦éšè·ç¦»é€’å‡
- å»ºç­‘æ•´ä½“å€’å¡Œåæ‰æ•£è½

### 4. **éœ‡æ’¼çš„è§†è§‰æ•ˆæœ**
- çˆ†ç‚¸ç¬é—´é—ªå…‰æ•ˆæœå’Œå…‰å¢å¼º
- çƒŸé›¾å’Œç°å°˜ç²’å­ç³»ç»Ÿ
- æ–¹å—é£æ•£ã€ç¿»æ»šã€ç¢°æ’çœŸå®æ•ˆæœ
- é˜´å½±å’Œå…‰ç…§åŠ¨æ€å˜åŒ–

### 5. **ç›´è§‚çš„äº¤äº’æ§åˆ¶**
- é¼ æ ‡å·¦é”®æ‹–åŠ¨æ—‹è½¬è§†è§’
- é¼ æ ‡å³é”®å¹³ç§»è§†è§’
- æ»šè½®ç¼©æ”¾ç„¦è·
- ä¸€é”®åˆ‡æ¢é¢„è§ˆè§’åº¦
- é‡ç½®åœºæ™¯æŒ‰é’®

æ¼”ç¤ºä¼šå…ˆåŠ è½½ä¸€ä¸ª60ç±³é«˜çš„åœ†å½¢ç –çŸ³å»ºç­‘ï¼Œç‚¹å‡»"å®æ–½å®šå‘çˆ†ç ´"æŒ‰é’®åï¼Œå»ºç­‘ä¼šåœ¨ç²¾ç¡®è®¾å®šçš„ä½ç½®çˆ†ç ´ï¼ŒéšåæŒ‰ç…§çœŸå®ç‰©ç†è§„å¾‹å€’å¡Œï¼Œè¥é€ å‡ºéœ‡æ’¼çš„å»ºç­‘æ‹†é™¤æ•ˆæœã€‚