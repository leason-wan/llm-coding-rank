<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D建筑爆破拆除演示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
        }
        
        button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #ff6666;
            transform: scale(1.05);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #explodeBtn {
            background: #ff0000;
            font-weight: bold;
            font-size: 16px;
        }
        
        #status {
            margin-top: 10px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <button id="explodeBtn">💥 引爆建筑</button>
            <button id="resetBtn">🔄 重置场景</button>
            <button id="cameraBtn">📷 切换视角</button>
            <div id="status">
                状态: 建筑稳定中... 
                <br>鼠标左键：旋转视角
                <br>鼠标右键：移动视角
                <br>滚轮：缩放
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.20.0/cannon.min.js"></script>
    
    <script>
        class BuildingDemolition {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.blocks = [];
                this.ground = null;
                this.particles = [];
                this.isExploded = false;
                this.cameraAngle = 0;
                
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupPhysics();
                this.createGround();
                this.createBuilding();
                this.setupLighting();
                this.setupControls();
                this.animate();
                
                // 让建筑稳定几秒
                setTimeout(() => {
                    this.updateStatus("建筑已稳定，准备就绪！");
                }, 3000);
            }
            
            setupScene() {
                // 创建场景
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x404040, 50, 200);
                
                // 创建相机
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(50, 30, 50);
                this.camera.lookAt(0, 15, 0);
                
                // 创建渲染器
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // 窗口调整
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupPhysics() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -30, 0); // 增强重力
                this.world.broadphase = new CANNON.SAPBroadphase(this.world);
                this.world.allowSleep = true;
                
                // 创建默认接触材料
                const defaultMaterial = new CANNON.Material('default');
                const defaultContactMaterial = new CANNON.ContactMaterial(
                    defaultMaterial,
                    defaultMaterial,
                    {
                        friction: 0.9,
                        restitution: 0.02
                    }
                );
                this.world.addContactMaterial(defaultContactMaterial);
                this.world.defaultContactMaterial = defaultContactMaterial;
            }
            
            createGround() {
                // 视觉地面
                const groundGeometry = new THREE.PlaneGeometry(80, 80);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x404040,
                    transparent: true,
                    opacity: 0.9
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // 物理地面
                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.add(groundBody);
            }
            
            createBuilding() {
                const radius = 3.2; // 调整半径确保20个方块围成圆形
                const blockSize = 1;
                const layers = 60;
                const blocksPerLayer = 20;
                
                // 创建方块几何体和材料
                const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                const blockMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C });
                
                // 创建物理材料
                const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize/2, blockSize/2, blockSize/2));
                
                this.blocks = [];
                
                for (let layer = 0; layer < layers; layer++) {
                    const y = layer * blockSize + blockSize/2;
                    const offsetAngle = (layer % 2) * (Math.PI / blocksPerLayer); // 错开排列
                    
                    for (let i = 0; i < blocksPerLayer; i++) {
                        const angle = (i / blocksPerLayer) * Math.PI * 2 + offsetAngle;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        // 创建视觉方块
                        const block = new THREE.Mesh(blockGeometry, blockMaterial.clone());
                        block.position.set(x, y, z);
                        block.castShadow = true;
                        this.scene.add(block);
                        
                        // 创建物理方块
                        const blockBody = new CANNON.Body({ 
                            mass: layer < 5 ? 2 : 1, // 底部方块更重
                            material: this.world.defaultContactMaterial.materials[0]
                        });
                        blockBody.addShape(blockShape);
                        blockBody.position.set(x, y, z);
                        blockBody.sleepSpeedLimit = 0.1;
                        blockBody.sleepTimeLimit = 0.1;
                        
                        this.world.add(blockBody);
                        
                        this.blocks.push({
                            mesh: block,
                            body: blockBody,
                            layer: layer,
                            index: i,
                            isExploded: false
                        });
                    }
                }
                
                // 强制所有方块进入睡眠状态
                setTimeout(() => {
                    this.blocks.forEach(block => {
                        block.body.sleep();
                    });
                }, 1000);
            }
            
            setupLighting() {
                // 环境光
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // 主光源
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }
            
            setupControls() {
                let isMouseDown = false;
                let mouseButton = -1;
                let mouseX = 0, mouseY = 0;
                let cameraRadius = 70;
                let cameraTheta = 0;
                let cameraPhi = Math.PI / 6;
                let cameraTarget = new THREE.Vector3(0, 15, 0);
                
                this.renderer.domElement.addEventListener('mousedown', (event) => {
                    isMouseDown = true;
                    mouseButton = event.button;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    event.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('mousemove', (event) => {
                    if (!isMouseDown) return;
                    
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    if (mouseButton === 0) { // 左键 - 旋转
                        cameraTheta -= deltaX * 0.01;
                        cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + deltaY * 0.01));
                    } else if (mouseButton === 2) { // 右键 - 移动
                        const moveSpeed = 0.1;
                        cameraTarget.x += deltaX * moveSpeed;
                        cameraTarget.y -= deltaY * moveSpeed;
                    }
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    
                    this.updateCamera(cameraRadius, cameraTheta, cameraPhi, cameraTarget);
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                this.renderer.domElement.addEventListener('wheel', (event) => {
                    cameraRadius += event.deltaY * 0.01;
                    cameraRadius = Math.max(10, Math.min(150, cameraRadius));
                    this.updateCamera(cameraRadius, cameraTheta, cameraPhi, cameraTarget);
                    event.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
                
                // 按钮事件
                document.getElementById('explodeBtn').addEventListener('click', () => {
                    this.explode();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('cameraBtn').addEventListener('click', () => {
                    this.switchCamera();
                });
            }
            
            updateCamera(radius, theta, phi, target) {
                this.camera.position.x = target.x + radius * Math.sin(phi) * Math.cos(theta);
                this.camera.position.y = target.y + radius * Math.cos(phi);
                this.camera.position.z = target.z + radius * Math.sin(phi) * Math.sin(theta);
                this.camera.lookAt(target);
            }
            
            explode() {
                if (this.isExploded) return;
                
                this.isExploded = true;
                this.updateStatus("💥 建筑爆破中...");
                
                // 禁用爆炸按钮
                document.getElementById('explodeBtn').disabled = true;
                
                // 创建爆炸效果
                this.createExplosionEffect();
                
                // 播放爆炸动画
                this.triggerExplosion();
                
                // 创建烟尘效果
                setTimeout(() => {
                    this.createSmokeEffect();
                }, 500);
                
                // 更新状态
                setTimeout(() => {
                    this.updateStatus("拆除完成！可以重置场景。");
                }, 5000);
            }
            
            createExplosionEffect() {
                // 爆炸光效
                const explosionLight = new THREE.PointLight(0xff4400, 5, 50);
                explosionLight.position.set(3, 1, 0);
                this.scene.add(explosionLight);
                
                // 光效衰减
                let intensity = 5;
                const fadeLight = () => {
                    intensity -= 0.1;
                    explosionLight.intensity = Math.max(0, intensity);
                    if (intensity > 0) {
                        setTimeout(fadeLight, 50);
                    } else {
                        this.scene.remove(explosionLight);
                    }
                };
                fadeLight();
            }
            
            triggerExplosion() {
                const explosionCenter = new CANNON.Vec3(3, 1, 0);
                const explosionRadius = 8;
                const explosionForce = 50;
                
                this.blocks.forEach(blockData => {
                    // 唤醒所有方块
                    blockData.body.wakeUp();
                    
                    const distance = blockData.body.position.distanceTo(explosionCenter);
                    
                    if (distance < explosionRadius) {
                        // 计算爆炸力
                        const direction = new CANNON.Vec3();
                        blockData.body.position.vsub(explosionCenter, direction);
                        direction.normalize();
                        
                        const force = explosionForce * (1 - distance / explosionRadius);
                        const impulse = direction.scale(force);
                        
                        // 添加随机性
                        impulse.x += (Math.random() - 0.5) * 10;
                        impulse.y += Math.random() * 20;
                        impulse.z += (Math.random() - 0.5) * 10;
                        
                        blockData.body.applyImpulse(impulse);
                        
                        // 添加旋转
                        const torque = new CANNON.Vec3(
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20
                        );
                        blockData.body.torque.vadd(torque, blockData.body.torque);
                        
                        blockData.isExploded = true;
                    }
                });
            }
            
            createSmokeEffect() {
                const smokeCount = 200;
                
                for (let i = 0; i < smokeCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.5, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x666666,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const smoke = new THREE.Mesh(geometry, material);
                    smoke.position.set(
                        (Math.random() - 0.5) * 20,
                        Math.random() * 5,
                        (Math.random() - 0.5) * 20
                    );
                    
                    this.scene.add(smoke);
                    
                    const particle = {
                        mesh: smoke,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            Math.random() * 0.5,
                            (Math.random() - 0.5) * 0.2
                        ),
                        life: 1.0
                    };
                    
                    this.particles.push(particle);
                }
            }
            
            switchCamera() {
                this.cameraAngle = (this.cameraAngle + 1) % 3;
                
                switch (this.cameraAngle) {
                    case 0: // 远景
                        this.camera.position.set(50, 30, 50);
                        this.camera.lookAt(0, 15, 0);
                        break;
                    case 1: // 侧视
                        this.camera.position.set(30, 10, 0);
                        this.camera.lookAt(0, 15, 0);
                        break;
                    case 2: // 近景
                        this.camera.position.set(15, 5, 15);
                        this.camera.lookAt(0, 5, 0);
                        break;
                }
            }
            
            reset() {
                // 清除现有建筑
                this.blocks.forEach(blockData => {
                    this.scene.remove(blockData.mesh);
                    this.world.remove(blockData.body);
                });
                this.blocks = [];
                
                // 清除粒子
                this.particles.forEach(particle => {
                    this.scene.remove(particle.mesh);
                });
                this.particles = [];
                
                // 重置状态
                this.isExploded = false;
                
                // 重新创建建筑
                this.createBuilding();
                
                // 重新启用按钮
                document.getElementById('explodeBtn').disabled = false;
                
                // 重置相机
                this.camera.position.set(50, 30, 50);
                this.camera.lookAt(0, 15, 0);
                
                this.updateStatus("场景已重置，建筑稳定中...");
                
                setTimeout(() => {
                    this.updateStatus("建筑已稳定，准备就绪！");
                }, 3000);
            }
            
            updateStatus(message) {
                document.getElementById('status').innerHTML = message + 
                    "<br>鼠标左键：旋转视角<br>鼠标右键：移动视角<br>滚轮：缩放";
            }
            
            updatePhysics() {
                this.world.step(1/60);
                
                // 更新方块位置
                this.blocks.forEach(blockData => {
                    blockData.mesh.position.copy(blockData.body.position);
                    blockData.mesh.quaternion.copy(blockData.body.quaternion);
                });
                
                // 更新粒子系统
                this.particles.forEach((particle, index) => {
                    particle.mesh.position.add(particle.velocity);
                    particle.mesh.position.y += particle.velocity.y;
                    particle.velocity.y -= 0.01; // 重力
                    
                    particle.life -= 0.01;
                    particle.mesh.material.opacity = particle.life * 0.3;
                    particle.mesh.scale.multiplyScalar(1.02);
                    
                    if (particle.life <= 0) {
                        this.scene.remove(particle.mesh);
                        this.particles.splice(index, 1);
                    }
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updatePhysics();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // 启动应用
        new BuildingDemolition();
    </script>
</body>
</html>
