<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då»ºç­‘çˆ†ç ´æ‹†é™¤æ¼”ç¤º</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
        }
        
        button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #ff6666;
            transform: scale(1.05);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #explodeBtn {
            background: #ff0000;
            font-weight: bold;
            font-size: 16px;
        }
        
        #status {
            margin-top: 10px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <button id="explodeBtn">ğŸ’¥ å¼•çˆ†å»ºç­‘</button>
            <button id="resetBtn">ğŸ”„ é‡ç½®åœºæ™¯</button>
            <button id="cameraBtn">ğŸ“· åˆ‡æ¢è§†è§’</button>
            <div id="status">
                çŠ¶æ€: å»ºç­‘ç¨³å®šä¸­... 
                <br>é¼ æ ‡å·¦é”®ï¼šæ—‹è½¬è§†è§’
                <br>é¼ æ ‡å³é”®ï¼šç§»åŠ¨è§†è§’
                <br>æ»šè½®ï¼šç¼©æ”¾
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.20.0/cannon.min.js"></script>
    
    <script>
        class BuildingDemolition {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.blocks = [];
                this.ground = null;
                this.particles = [];
                this.isExploded = false;
                this.cameraAngle = 0;
                
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupPhysics();
                this.createGround();
                this.createBuilding();
                this.setupLighting();
                this.setupControls();
                this.animate();
                
                // è®©å»ºç­‘ç¨³å®šå‡ ç§’
                setTimeout(() => {
                    this.updateStatus("å»ºç­‘å·²ç¨³å®šï¼Œå‡†å¤‡å°±ç»ªï¼");
                }, 3000);
            }
            
            setupScene() {
                // åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x404040, 50, 200);
                
                // åˆ›å»ºç›¸æœº
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(50, 30, 50);
                this.camera.lookAt(0, 15, 0);
                
                // åˆ›å»ºæ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x87CEEB);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // çª—å£è°ƒæ•´
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupPhysics() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -30, 0); // å¢å¼ºé‡åŠ›
                this.world.broadphase = new CANNON.SAPBroadphase(this.world);
                this.world.allowSleep = true;
                
                // åˆ›å»ºé»˜è®¤æ¥è§¦ææ–™
                const defaultMaterial = new CANNON.Material('default');
                const defaultContactMaterial = new CANNON.ContactMaterial(
                    defaultMaterial,
                    defaultMaterial,
                    {
                        friction: 0.9,
                        restitution: 0.02
                    }
                );
                this.world.addContactMaterial(defaultContactMaterial);
                this.world.defaultContactMaterial = defaultContactMaterial;
            }
            
            createGround() {
                // è§†è§‰åœ°é¢
                const groundGeometry = new THREE.PlaneGeometry(80, 80);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x404040,
                    transparent: true,
                    opacity: 0.9
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // ç‰©ç†åœ°é¢
                const groundShape = new CANNON.Plane();
                const groundBody = new CANNON.Body({ mass: 0 });
                groundBody.addShape(groundShape);
                groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.add(groundBody);
            }
            
            createBuilding() {
                const radius = 3.2; // è°ƒæ•´åŠå¾„ç¡®ä¿20ä¸ªæ–¹å—å›´æˆåœ†å½¢
                const blockSize = 1;
                const layers = 60;
                const blocksPerLayer = 20;
                
                // åˆ›å»ºæ–¹å—å‡ ä½•ä½“å’Œææ–™
                const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                const blockMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C });
                
                // åˆ›å»ºç‰©ç†ææ–™
                const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize/2, blockSize/2, blockSize/2));
                
                this.blocks = [];
                
                for (let layer = 0; layer < layers; layer++) {
                    const y = layer * blockSize + blockSize/2;
                    const offsetAngle = (layer % 2) * (Math.PI / blocksPerLayer); // é”™å¼€æ’åˆ—
                    
                    for (let i = 0; i < blocksPerLayer; i++) {
                        const angle = (i / blocksPerLayer) * Math.PI * 2 + offsetAngle;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        // åˆ›å»ºè§†è§‰æ–¹å—
                        const block = new THREE.Mesh(blockGeometry, blockMaterial.clone());
                        block.position.set(x, y, z);
                        block.castShadow = true;
                        this.scene.add(block);
                        
                        // åˆ›å»ºç‰©ç†æ–¹å—
                        const blockBody = new CANNON.Body({ 
                            mass: layer < 5 ? 2 : 1, // åº•éƒ¨æ–¹å—æ›´é‡
                            material: this.world.defaultContactMaterial.materials[0]
                        });
                        blockBody.addShape(blockShape);
                        blockBody.position.set(x, y, z);
                        blockBody.sleepSpeedLimit = 0.1;
                        blockBody.sleepTimeLimit = 0.1;
                        
                        this.world.add(blockBody);
                        
                        this.blocks.push({
                            mesh: block,
                            body: blockBody,
                            layer: layer,
                            index: i,
                            isExploded: false
                        });
                    }
                }
                
                // å¼ºåˆ¶æ‰€æœ‰æ–¹å—è¿›å…¥ç¡çœ çŠ¶æ€
                setTimeout(() => {
                    this.blocks.forEach(block => {
                        block.body.sleep();
                    });
                }, 1000);
            }
            
            setupLighting() {
                // ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                // ä¸»å…‰æº
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 500;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }
            
            setupControls() {
                let isMouseDown = false;
                let mouseButton = -1;
                let mouseX = 0, mouseY = 0;
                let cameraRadius = 70;
                let cameraTheta = 0;
                let cameraPhi = Math.PI / 6;
                let cameraTarget = new THREE.Vector3(0, 15, 0);
                
                this.renderer.domElement.addEventListener('mousedown', (event) => {
                    isMouseDown = true;
                    mouseButton = event.button;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    event.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('mousemove', (event) => {
                    if (!isMouseDown) return;
                    
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    if (mouseButton === 0) { // å·¦é”® - æ—‹è½¬
                        cameraTheta -= deltaX * 0.01;
                        cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi + deltaY * 0.01));
                    } else if (mouseButton === 2) { // å³é”® - ç§»åŠ¨
                        const moveSpeed = 0.1;
                        cameraTarget.x += deltaX * moveSpeed;
                        cameraTarget.y -= deltaY * moveSpeed;
                    }
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    
                    this.updateCamera(cameraRadius, cameraTheta, cameraPhi, cameraTarget);
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });
                
                this.renderer.domElement.addEventListener('wheel', (event) => {
                    cameraRadius += event.deltaY * 0.01;
                    cameraRadius = Math.max(10, Math.min(150, cameraRadius));
                    this.updateCamera(cameraRadius, cameraTheta, cameraPhi, cameraTarget);
                    event.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
                
                // æŒ‰é’®äº‹ä»¶
                document.getElementById('explodeBtn').addEventListener('click', () => {
                    this.explode();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('cameraBtn').addEventListener('click', () => {
                    this.switchCamera();
                });
            }
            
            updateCamera(radius, theta, phi, target) {
                this.camera.position.x = target.x + radius * Math.sin(phi) * Math.cos(theta);
                this.camera.position.y = target.y + radius * Math.cos(phi);
                this.camera.position.z = target.z + radius * Math.sin(phi) * Math.sin(theta);
                this.camera.lookAt(target);
            }
            
            explode() {
                if (this.isExploded) return;
                
                this.isExploded = true;
                this.updateStatus("ğŸ’¥ å»ºç­‘çˆ†ç ´ä¸­...");
                
                // ç¦ç”¨çˆ†ç‚¸æŒ‰é’®
                document.getElementById('explodeBtn').disabled = true;
                
                // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                this.createExplosionEffect();
                
                // æ’­æ”¾çˆ†ç‚¸åŠ¨ç”»
                this.triggerExplosion();
                
                // åˆ›å»ºçƒŸå°˜æ•ˆæœ
                setTimeout(() => {
                    this.createSmokeEffect();
                }, 500);
                
                // æ›´æ–°çŠ¶æ€
                setTimeout(() => {
                    this.updateStatus("æ‹†é™¤å®Œæˆï¼å¯ä»¥é‡ç½®åœºæ™¯ã€‚");
                }, 5000);
            }
            
            createExplosionEffect() {
                // çˆ†ç‚¸å…‰æ•ˆ
                const explosionLight = new THREE.PointLight(0xff4400, 5, 50);
                explosionLight.position.set(3, 1, 0);
                this.scene.add(explosionLight);
                
                // å…‰æ•ˆè¡°å‡
                let intensity = 5;
                const fadeLight = () => {
                    intensity -= 0.1;
                    explosionLight.intensity = Math.max(0, intensity);
                    if (intensity > 0) {
                        setTimeout(fadeLight, 50);
                    } else {
                        this.scene.remove(explosionLight);
                    }
                };
                fadeLight();
            }
            
            triggerExplosion() {
                const explosionCenter = new CANNON.Vec3(3, 1, 0);
                const explosionRadius = 8;
                const explosionForce = 50;
                
                this.blocks.forEach(blockData => {
                    // å”¤é†’æ‰€æœ‰æ–¹å—
                    blockData.body.wakeUp();
                    
                    const distance = blockData.body.position.distanceTo(explosionCenter);
                    
                    if (distance < explosionRadius) {
                        // è®¡ç®—çˆ†ç‚¸åŠ›
                        const direction = new CANNON.Vec3();
                        blockData.body.position.vsub(explosionCenter, direction);
                        direction.normalize();
                        
                        const force = explosionForce * (1 - distance / explosionRadius);
                        const impulse = direction.scale(force);
                        
                        // æ·»åŠ éšæœºæ€§
                        impulse.x += (Math.random() - 0.5) * 10;
                        impulse.y += Math.random() * 20;
                        impulse.z += (Math.random() - 0.5) * 10;
                        
                        blockData.body.applyImpulse(impulse);
                        
                        // æ·»åŠ æ—‹è½¬
                        const torque = new CANNON.Vec3(
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20
                        );
                        blockData.body.torque.vadd(torque, blockData.body.torque);
                        
                        blockData.isExploded = true;
                    }
                });
            }
            
            createSmokeEffect() {
                const smokeCount = 200;
                
                for (let i = 0; i < smokeCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.5, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x666666,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const smoke = new THREE.Mesh(geometry, material);
                    smoke.position.set(
                        (Math.random() - 0.5) * 20,
                        Math.random() * 5,
                        (Math.random() - 0.5) * 20
                    );
                    
                    this.scene.add(smoke);
                    
                    const particle = {
                        mesh: smoke,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            Math.random() * 0.5,
                            (Math.random() - 0.5) * 0.2
                        ),
                        life: 1.0
                    };
                    
                    this.particles.push(particle);
                }
            }
            
            switchCamera() {
                this.cameraAngle = (this.cameraAngle + 1) % 3;
                
                switch (this.cameraAngle) {
                    case 0: // è¿œæ™¯
                        this.camera.position.set(50, 30, 50);
                        this.camera.lookAt(0, 15, 0);
                        break;
                    case 1: // ä¾§è§†
                        this.camera.position.set(30, 10, 0);
                        this.camera.lookAt(0, 15, 0);
                        break;
                    case 2: // è¿‘æ™¯
                        this.camera.position.set(15, 5, 15);
                        this.camera.lookAt(0, 5, 0);
                        break;
                }
            }
            
            reset() {
                // æ¸…é™¤ç°æœ‰å»ºç­‘
                this.blocks.forEach(blockData => {
                    this.scene.remove(blockData.mesh);
                    this.world.remove(blockData.body);
                });
                this.blocks = [];
                
                // æ¸…é™¤ç²’å­
                this.particles.forEach(particle => {
                    this.scene.remove(particle.mesh);
                });
                this.particles = [];
                
                // é‡ç½®çŠ¶æ€
                this.isExploded = false;
                
                // é‡æ–°åˆ›å»ºå»ºç­‘
                this.createBuilding();
                
                // é‡æ–°å¯ç”¨æŒ‰é’®
                document.getElementById('explodeBtn').disabled = false;
                
                // é‡ç½®ç›¸æœº
                this.camera.position.set(50, 30, 50);
                this.camera.lookAt(0, 15, 0);
                
                this.updateStatus("åœºæ™¯å·²é‡ç½®ï¼Œå»ºç­‘ç¨³å®šä¸­...");
                
                setTimeout(() => {
                    this.updateStatus("å»ºç­‘å·²ç¨³å®šï¼Œå‡†å¤‡å°±ç»ªï¼");
                }, 3000);
            }
            
            updateStatus(message) {
                document.getElementById('status').innerHTML = message + 
                    "<br>é¼ æ ‡å·¦é”®ï¼šæ—‹è½¬è§†è§’<br>é¼ æ ‡å³é”®ï¼šç§»åŠ¨è§†è§’<br>æ»šè½®ï¼šç¼©æ”¾";
            }
            
            updatePhysics() {
                this.world.step(1/60);
                
                // æ›´æ–°æ–¹å—ä½ç½®
                this.blocks.forEach(blockData => {
                    blockData.mesh.position.copy(blockData.body.position);
                    blockData.mesh.quaternion.copy(blockData.body.quaternion);
                });
                
                // æ›´æ–°ç²’å­ç³»ç»Ÿ
                this.particles.forEach((particle, index) => {
                    particle.mesh.position.add(particle.velocity);
                    particle.mesh.position.y += particle.velocity.y;
                    particle.velocity.y -= 0.01; // é‡åŠ›
                    
                    particle.life -= 0.01;
                    particle.mesh.material.opacity = particle.life * 0.3;
                    particle.mesh.scale.multiplyScalar(1.02);
                    
                    if (particle.life <= 0) {
                        this.scene.remove(particle.mesh);
                        this.particles.splice(index, 1);
                    }
                });
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updatePhysics();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // å¯åŠ¨åº”ç”¨
        new BuildingDemolition();
    </script>
</body>
</html>
