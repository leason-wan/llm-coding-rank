<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Three.js & Cannon.js 3D建筑拆除演示</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-family: sans-serif;
        }
        button {
            display: block;
            margin-bottom: 8px;
            padding: 8px 12px;
            cursor: pointer;
            background-color: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            width: 150px;
            text-align: center;
        }
        button:hover { background-color: #555; }
        button:active { background-color: #333; }
        #info {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <button id="explodeBtn">引爆</button>
        <button id="resetBtn">重置场景</button>
        <button id="cameraBtn">切换视角</button>
        <div id="info">
            鼠标左键: 旋转视角<br>
            鼠标右键: 平移视角<br>
            滚轮: 缩放
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- 全局变量 ---
        let scene, camera, renderer, controls;
        let world, groundBody, timeStep = 1 / 60;
        let bodies = [], meshes = [];
        let particles, particleSystem;
        let ambientLight, directionalLight, explosionLight;

        const clock = new THREE.Clock();
        let isExploded = false;
        let isTopView = false;
        
        // 建筑参数
        const numFloors = 60;
        const numBlocksPerFloor = 20;
        const blockHeight = 0.5;
        const blockDepth = 0.75;
        const blockWidth = 2.0;
        const buildingRadius = (numBlocksPerFloor * blockWidth) / (2 * Math.PI) * 1.05; // 乘以1.05确保紧密贴合

        init();
        animate();

        // --- 初始化函数 ---
        function init() {
            initThree();
            initCannon();
            initControls();
            initLights();
            initUI();
            
            createGround();
            createBuilding();

            window.addEventListener('resize', onWindowResize, false);
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x333333, 100, 250);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 20, 25);
            camera.lookAt(0, 15, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x111111);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
        }

        function initCannon() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            
            // 允许物理体睡眠，这是初始静止的关键
            world.allowSleep = true;

            // 定义物理材质
            const groundMaterial = new CANNON.Material("groundMaterial");
            const brickMaterial = new CANNON.Material("brickMaterial");

            // 定义砖块与砖块之间的接触属性 (模拟砂浆)
            // 高摩擦力，极低弹性
            const brick_brick_contact = new CANNON.ContactMaterial(brickMaterial, brickMaterial, {
                friction: 0.9,
                restitution: 0.01,
            });
            world.addContactMaterial(brick_brick_contact);

            // 定义砖块与地面之间的接触属性
            const brick_ground_contact = new CANNON.ContactMaterial(brickMaterial, groundMaterial, {
                friction: 0.4,
                restitution: 0.1,
            });
            world.addContactMaterial(brick_ground_contact);
        }

        function initControls() {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 15, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 150;
        }

        function initLights() {
            ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // 用于爆炸瞬间的闪光
            explosionLight = new THREE.PointLight(0xffaa44, 0, 100, 2);
            scene.add(explosionLight);
        }

        function initUI() {
            document.getElementById('explodeBtn').addEventListener('click', explode);
            document.getElementById('resetBtn').addEventListener('click', resetScene);
            document.getElementById('cameraBtn').addEventListener('click', toggleCamera);
        }

        // --- 场景物体创建 ---
        function createGround() {
            const groundGeo = new THREE.PlaneGeometry(80, 80);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.8 });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            const groundShape = new CANNON.Plane();
            groundBody = new CANNON.Body({ mass: 0, material: world.contactmaterials[1].materials[0] });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }

        function createBuilding() {
            const brickGeo = new THREE.BoxGeometry(blockWidth, blockHeight, blockDepth);
            const brickMat = new THREE.MeshStandardMaterial({ color: 0xF5F5DC, roughness: 0.7 });
            const brickShape = new CANNON.Box(new CANNON.Vec3(blockWidth / 2, blockHeight / 2, blockDepth / 2));

            for (let y = 0; y < numFloors; y++) {
                for (let i = 0; i < numBlocksPerFloor; i++) {
                    const angleOffset = (y % 2 === 0) ? 0 : 0.5;
                    const angle = ((i + angleOffset) / numBlocksPerFloor) * Math.PI * 2;
                    
                    const x = buildingRadius * Math.cos(angle);
                    const z = buildingRadius * Math.sin(angle);
                    const positionY = y * blockHeight + blockHeight / 2;

                    // 创建 Three.js 网格
                    const mesh = new THREE.Mesh(brickGeo, brickMat);
                    mesh.position.set(x, positionY, z);
                    mesh.rotation.y = -angle; // 对齐到圆周
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    meshes.push(mesh);

                    // 创建 Cannon.js 物理体
                    const body = new CANNON.Body({
                        mass: 5,
                        position: new CANNON.Vec3(x, positionY, z),
                        shape: brickShape,
                        material: world.contactmaterials[0].materials[0]
                    });
                    body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -angle);
                    
                    // **核心：让物理体进入睡眠状态以保证初始静止**
                    body.allowSleep = true;
                    body.sleep();

                    world.addBody(body);
                    bodies.push(body);
                }
            }
        }
        
        function createParticleSystem() {
            const particleCount = 5000;
            const particlesGeo = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            
            // 自定义属性，用于控制每个粒子的生命周期和速度
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                posArray[i * 3 + 0] = 0;
                posArray[i * 3 + 1] = -10; // 初始隐藏在地面下
                posArray[i * 3 + 2] = 0;

                velocities[i * 3 + 0] = 0;
                velocities[i * 3 + 1] = 0;
                velocities[i * 3 + 2] = 0;

                lifetimes[i] = 0;
            }

            particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            particlesGeo.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            particlesGeo.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            
            const particleTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/particle2.png');
            const particleMat = new THREE.PointsMaterial({
                size: 0.8,
                map: particleTexture,
                blending: THREE.NormalBlending,
                transparent: true,
                depthWrite: false, // 避免粒子间难看的遮挡
                color: 0x888888,
                opacity: 0, // 初始不可见
            });

            particleSystem = new THREE.Points(particlesGeo, particleMat);
            scene.add(particleSystem);
            particles = {
                geometry: particlesGeo,
                material: particleMat,
                spawned: false
            };
        }


        // --- 控制与交互 ---
        function explode() {
            if (isExploded) return;
            isExploded = true;
            
            document.getElementById('explodeBtn').disabled = true;
            document.getElementById('explodeBtn').style.cursor = 'not-allowed';
            document.getElementById('explodeBtn').style.backgroundColor = '#222';

            // 1. 唤醒所有物理体
            bodies.forEach(body => body.wakeUp());
            
            // 2. 找到爆炸点 (第1层最右侧的方块，即bodies数组的第一个元素)
            const explosionSourceBody = bodies[0];
            const explosionPos = explosionSourceBody.position.clone();

            // 3. 施加冲击波
            const explosionRadius = 2.0;
            const explosionStrength = 4.0; // 基础冲击力

            bodies.forEach(body => {
                const distVec = new CANNON.Vec3();
                body.position.vsub(explosionPos, distVec);
                const distance = distVec.length();

                if (distance < explosionRadius) {
                    const impulse = new CANNON.Vec3();
                    distVec.normalize();
                    // 冲击力随距离衰减
                    const strength = explosionStrength * (1 - distance / explosionRadius);
                    const randomFactor = Math.random() * 1.5 + 1.5; // 2-5之间的随机冲击力
                    impulse.copy(distVec.scale(strength * randomFactor));
                    
                    // 施加冲量
                    body.applyImpulse(impulse, body.position);
                }
            });

            // 4. 视觉效果
            // 闪光
            explosionLight.position.copy(explosionPos);
            explosionLight.intensity = 200;
            
            // 烟尘
            if(!particleSystem) createParticleSystem();
            spawnDustCloud(explosionPos);
        }
        
        function spawnDustCloud(position) {
            particles.spawned = true;
            const posAttribute = particles.geometry.getAttribute('position');
            const velAttribute = particles.geometry.getAttribute('velocity');
            const lifeAttribute = particles.geometry.getAttribute('lifetime');
            
            for(let i = 0; i < posAttribute.count; i++) {
                posAttribute.setXYZ(i, position.x, position.y, position.z);
                
                // 随机方向和速度
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const speed = Math.random() * 5 + 2;
                velAttribute.setXYZ(
                    i,
                    speed * Math.sin(phi) * Math.cos(theta),
                    speed * Math.cos(phi) * 0.5 + 1, // 略微向上
                    speed * Math.sin(phi) * Math.sin(theta)
                );
                
                lifeAttribute.setX(i, Math.random() * 3 + 4); // 4-7秒的生命周期
            }
            posAttribute.needsUpdate = true;
            velAttribute.needsUpdate = true;
            lifeAttribute.needsUpdate = true;
            particles.material.opacity = 0.5;
        }

        function updateParticles(delta) {
            if (!particles || !particles.spawned) return;
            
            const posAttribute = particles.geometry.getAttribute('position');
            const velAttribute = particles.geometry.getAttribute('velocity');
            const lifeAttribute = particles.geometry.getAttribute('lifetime');
            let aliveParticles = 0;

            for(let i = 0; i < posAttribute.count; i++) {
                let life = lifeAttribute.getX(i);
                if(life > 0) {
                    life -= delta;
                    
                    const vx = velAttribute.getX(i);
                    const vy = velAttribute.getY(i);
                    const vz = velAttribute.getZ(i);

                    posAttribute.setXYZ(
                        i,
                        posAttribute.getX(i) + vx * delta,
                        posAttribute.getY(i) + vy * delta,
                        posAttribute.getZ(i) + vz * delta
                    );
                    
                    // 模拟空气阻力和重力
                    velAttribute.setXYZ(i, vx * 0.98, vy * 0.98 - 0.5 * delta, vz * 0.98);

                    lifeAttribute.setX(i, life);
                    aliveParticles++;
                }
            }
            
            // 随时间慢慢消散
            particles.material.opacity = Math.min(0.5, aliveParticles / (posAttribute.count / 4));
            
            posAttribute.needsUpdate = true;
            velAttribute.needsUpdate = true;
        }


        function resetScene() {
            isExploded = false;
            
            document.getElementById('explodeBtn').disabled = false;
            document.getElementById('explodeBtn').style.cursor = 'pointer';
            document.getElementById('explodeBtn').style.backgroundColor = '#444';

            // 清理物理世界
            bodies.forEach(body => world.remove(body));
            
            // 清理 Three.js 场景
            meshes.forEach(mesh => scene.remove(mesh));

            // 清理粒子系统
            if(particleSystem) {
                scene.remove(particleSystem);
                particleSystem.geometry.dispose();
                particleSystem.material.dispose();
                particleSystem = null;
                particles = null;
            }
            
            // 重置数组
            bodies = [];
            meshes = [];

            // 重建建筑
            createBuilding();

            // 重置相机
            isTopView = false;
            camera.position.set(25, 20, 25);
            controls.target.set(0, 15, 0);
        }

        function toggleCamera() {
            isTopView = !isTopView;
            if (isTopView) {
                camera.position.set(0, 100, 0.1);
                controls.target.set(0, 0, 0);
            } else {
                camera.position.set(25, 20, 25);
                controls.target.set(0, 15, 0);
            }
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // 只有在爆炸后才开始密集的物理计算
            if (isExploded) {
                world.step(timeStep, delta, 3);
            }

            // 同步物理体和渲染网格
            for (let i = 0; i < bodies.length; i++) {
                meshes[i].position.copy(bodies[i].position);
                meshes[i].quaternion.copy(bodies[i].quaternion);
            }

            // 更新闪光效果
            if (explosionLight.intensity > 0) {
                explosionLight.intensity *= 0.92; // 快速衰减
                if(explosionLight.intensity < 0.1) explosionLight.intensity = 0;
            }

            // 更新烟尘效果
            updateParticles(delta);

            // 随着烟尘弥漫，场景变暗
            if (particles && particles.spawned) {
                const maxOpacity = particles.material.opacity;
                ambientLight.intensity = 1.5 * (1 - maxOpacity * 0.8);
                directionalLight.intensity = 1.5 * (1 - maxOpacity * 0.8);
            } else {
                ambientLight.intensity = 1.5;
                directionalLight.intensity = 1.5;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>