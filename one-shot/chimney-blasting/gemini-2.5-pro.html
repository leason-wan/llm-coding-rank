<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Building Demolition - Three.js & Cannon-es</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: Arial, sans-serif; }
        #container { position: absolute; top: 0; left: 0; }
        #ui-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        button {
            background-color: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        button:hover { background-color: #555; }
        button:disabled { background-color: #222; color: #888; cursor: not-allowed; }
        .info { font-size: 12px; color: #ccc; max-width: 200px;}
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui-controls">
        <button id="explode-btn">引爆 (Explode)</button>
        <button id="reset-btn">重置 (Reset)</button>
        <button id="camera-btn">切换视角 (Toggle Camera)</button>
        <div class="info">
            左键: 旋转视角<br>
            右键: 平移场景<br>
            滚轮: 缩放
        </div>
    </div>

    <!-- ES Module Shims for browser compatibility -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.mjs",
            "cannon-es-debugger": "https://unpkg.com/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.mjs"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        let scene, camera, renderer, controls, clock;
        let world;
        const objectsToUpdate = [];
        let explosion_triggered = false;

        // --- PARTICLE SYSTEM ---
        let smokeParticles, dustParticles;
        let explosionLight;

        // --- CONSTANTS ---
        const numBlocksPerLevel = 20;
        const numLevels = 60;
        const blockHeight = 0.5;
        const blockDepth = 1;
        const blockWidth = 2.1; // Slightly wider to ensure good contact on the curve
        const buildingRadius = (blockWidth / 2) / Math.sin(Math.PI / numBlocksPerLevel) * 1.02; // Precise calculation + slight overlap

        function init() {
            // --- Three.js Setup ---
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x222222, 50, 150);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(35, 20, 35);
            camera.lookAt(0, 15, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a1a);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.top = 40;
            directionalLight.shadow.camera.bottom = -40;
            directionalLight.shadow.camera.left = -40;
            directionalLight.shadow.camera.right = 40;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Explosion light (initially off)
            explosionLight = new THREE.PointLight(0xffaa33, 0, 100, 2);
            scene.add(explosionLight);


            // --- Controls ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 15, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below ground

            // --- Cannon-es Setup ---
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0),
                allowSleep: true, // Enable sleeping
            });
            world.solver.iterations = 15; // More iterations for stability

            // --- Materials & Physics ---
            createMaterials();
            createGround();
            createBuilding();
            createParticles();
            
            // --- UI ---
            setupUI();

            // --- Clock & Animation Loop ---
            clock = new THREE.Clock();
            animate();

            window.addEventListener('resize', onWindowResize);
        }
        
        function createMaterials() {
            const groundMaterial = new CANNON.Material('ground');
            const brickMaterial = new CANNON.Material('brick');

            // Contact material to simulate mortar (high friction, low bounce)
            const brick_ground = new CANNON.ContactMaterial(groundMaterial, brickMaterial, {
                friction: 0.7,
                restitution: 0.1,
            });
            world.addContactMaterial(brick_ground);

            // IMPORTANT: Brick-to-brick contact simulates cohesion
            const brick_brick = new CANNON.ContactMaterial(brickMaterial, brickMaterial, {
                friction: 0.85,  // High friction to simulate stickiness
                restitution: 0.01, // Very low restitution to absorb impact
            });
            world.addContactMaterial(brick_brick);
        }

        function createGround() {
            // Three.js visual ground
            const groundGeo = new THREE.PlaneGeometry(80, 80);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a4a4a, // Deep grey
                roughness: 0.8,
                metalness: 0.2
            });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Cannon-es physical ground
            const groundBody = new CANNON.Body({
                mass: 0, // static
                shape: new CANNON.Plane(),
                material: world.materials.find(m => m.name === 'ground')
            });
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);
        }

        function createBuilding() {
            const blockGeo = new THREE.BoxGeometry(blockWidth, blockHeight, blockDepth);
            const blockMat = new THREE.MeshStandardMaterial({ 
                color: 0xF5F5DC, // Beige
                roughness: 0.9,
                metalness: 0.1,
            });
            const blockShape = new CANNON.Box(new CANNON.Vec3(blockWidth / 2, blockHeight / 2, blockDepth / 2));
            const brickMaterial = world.materials.find(m => m.name === 'brick');

            for (let y = 0; y < numLevels; y++) {
                for (let i = 0; i < numBlocksPerLevel; i++) {
                    const mass = 10;
                    
                    // Staggered brick pattern
                    const offset = (y % 2 === 0) ? 0 : 0.5;
                    const angle = ((i + offset) / numBlocksPerLevel) * Math.PI * 2;
                    
                    const x = Math.cos(angle) * buildingRadius;
                    const z = Math.sin(angle) * buildingRadius;
                    const position = new CANNON.Vec3(x, y * blockHeight + blockHeight / 2, z);

                    // Create Mesh
                    const mesh = new THREE.Mesh(blockGeo, blockMat);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    
                    // Create Body
                    const body = new CANNON.Body({ mass, position, shape: blockShape, material: brickMaterial });
                    body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -angle); // Rotate block to face outwards
                    world.addBody(body);

                    // IMPORTANT: Force the body to sleep initially for a perfectly static start
                    body.sleep();
                    
                    objectsToUpdate.push({ mesh, body });
                }
            }
            console.log(`Building created with ${objectsToUpdate.length} blocks.`);
        }
        
        function createParticles() {
            // Smoke particles
            const smokeGeo = new THREE.BufferGeometry();
            const smokeVertices = [];
            const smokeTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAYKADAAQAAAABAAAAYAAAAACpM19OAAAEaUlEQVR4Ae2d/VNUQRDH/+8cQGQCJQI1AioCVgIqAlQCJQIqAipCVAIqAlQCJQIqAnp7725y723n3T15v7d3+7k3N+vNWXp39+/s3tlFCH5vIuGBAmwSgZ8UAUVAEVAEVAAEVAEVgAARUAEVAEVgAFQAFYAAEVABVAAFgAFQAVYAAURABVABVgAFQAVYAAURABVABVAAFgAFQABRABVQAFQAFQAVYAAURABVABVAAFgAFQABRABVQAFYAFQAVYAAURABVQAFVgAFQAVYAAURABVQBVgAFQAVYAAURABVABVAAFgAFQABRABVQAFQAVYAAURABVQBVgAFQAVYAAURABVABVgAFQAVYAAURABVQAFVgAFQAVYAAURABVQAFQAVYAAUQAN+L+Ie1hQvAX1X9I/A/h/r++9vXf1+273IAPwXwXwL+L8b7VwB/FvF7EX+pBfA84nMR/xfx3Yj/vH25gR1AuMi+d/0i4vMRn4sIsBv+r4i/E/FvEf/y9kUBfsyC/xTx8YjP63sPABNfF/E/Ef+pBfBEIv5JxDMRf3f7QgF+w533j0T8t4h/rAswAGqBvBXxfxGf/P1gAFQI+DMR74r4uYg7dAsAXsR7I/5AxOcj/r21AF8F8QcRnyfio4i36b4nwBfB+DkRfz/if0T8/b4VwI9g/FLERxPxfhF/VBeAsBH/T8QnEZ8F8dO6BbBfiP/7fS+B38I4t/j3BvwJ/FkE3gRwG8c4Dvgx/NsIvA7gOY43HvC38LcReBPAfRwvOuCH8AcReCPAbRznKeBv4Xci8BqA7zveaMDvg1/F4O0AznC82YBPwR9H4I0APuF4hwJ/Dn8WgbcCeI7jVQd8NfxeBN4K4DGOVxfw+fADEXgTwDEcrzTgq+FXInAvgGM53njAF+EnInA/gGM5XnDAT8JPReB+APdzvNSA/xD+SgTuAfA0xzMO+Bv4XQicA+BpjhcZ8Ef4LQicA2Bpjjca8Gf4pQgcAmBZjhcc8LfwuRA4BMBiHO8y4J/hp0LgFADLcby/AP/B/x7+u5t/AD/z8z3/G/57uP+jYv8D0V8r+H/D/0f5Pyl1f6H4/8/y/xS7f1L+/0v+f2LzD/7jT974D/x3S/9H0/6P4n2g+w+u/0f7P4r332P9H8/7j579j+p94NsPcv8B5/8j/T/R/Y+g/wfo/kPefxDtP3j/w99/kPwPuv9g6z/Y/oep/2DrP9j6D7b+g+3/MPf/yP3/sP+f2P4P9v6D7X+w/Q9z/8Hcf7D9D3P/wfZ/MPcfzP0H8+85/54F+DeEf3T5Z7P+WfC/2/x3n/3/s/3/sP1/sP0Psv9B9j+I/ge5/0H2P4j+B7n/Qe4/yP4Hsf/A9j/Y/ge5/2D7H2z/A7n/wPY/2P6Huf/A9j/Y/ge5/2D7H2z/A9z/MPcf7P1H999333333Xf/8mQoAioAioAioAioACoAgURABVQAFQABkAFQAVYAAURABVQBVgAFQAVYAAURABVQBVgAFQAVYAAURABVQBVAAFgAFQAVYAAURABVABVgAFQAVYAAURABVABVAAFgAFQAVYAAURABVABVAAFgAFQAVYAAURABVQAFQAVYAAURABVQAFQAVYAAURABVQBVgAFQAVYAAURAFeBf8XgD8aYw+tLAAAAAElFTkSuQmCC');
            
            for (let i = 0; i < 200; i++) {
                smokeVertices.push(0, 0, 0);
            }
            smokeGeo.setAttribute('position', new THREE.Float32BufferAttribute(smokeVertices, 3));
            
            const smokeMat = new THREE.PointsMaterial({
                size: 6,
                map: smokeTexture,
                blending: THREE.NormalBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.7
            });
            
            smokeParticles = new THREE.Points(smokeGeo, smokeMat);
            smokeParticles.visible = false;
            scene.add(smokeParticles);

            // Dust particles (smaller, more numerous)
            const dustGeo = new THREE.BufferGeometry();
            const dustVertices = [];
            for (let i = 0; i < 500; i++) {
                dustVertices.push(0, 0, 0);
            }
            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
            
            const dustMat = new THREE.PointsMaterial({
                size: 2,
                map: smokeTexture,
                blending: THREE.NormalBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.5
            });

            dustParticles = new THREE.Points(dustGeo, dustMat);
            dustParticles.visible = false;
            scene.add(dustParticles);
        }

        function setupUI() {
            document.getElementById('explode-btn').addEventListener('click', () => {
                if (explosion_triggered) return;
                triggerExplosion();
            });
            document.getElementById('reset-btn').addEventListener('click', () => location.reload());
            document.getElementById('camera-btn').addEventListener('click', toggleCamera);
        }

        function triggerExplosion() {
            explosion_triggered = true;
            document.getElementById('explode-btn').disabled = true;

            // Define explosion point: first level, rightmost block
            const explosionPos = new CANNON.Vec3(buildingRadius, blockHeight / 2, 0);
            const explosionRadius = 2.0;
            const explosionStrength = 4;

            // Light flash
            explosionLight.position.copy(explosionPos);
            explosionLight.intensity = 500;
            scene.getObjectByName("AmbientLight").intensity = 0.5;
            scene.getObjectByName("DirectionalLight").intensity = 0.5;

            // Activate particles
            activateParticles(explosionPos);

            // Wake up and apply impulse
            objectsToUpdate.forEach(({ body }) => {
                const dist = body.position.distanceTo(explosionPos);

                if (dist < explosionRadius * 4) { // Wake up bodies in a larger radius
                    body.wakeUp();
                }

                if (dist < explosionRadius) {
                    const forceDir = new CANNON.Vec3();
                    body.position.vsub(explosionPos, forceDir);
                    forceDir.normalize();
                    
                    const strength = explosionStrength * (1 - dist / explosionRadius);
                    const impulse = forceDir.scale(strength * body.mass * (2 + Math.random() * 3)); // Randomize impulse a bit
                    body.applyImpulse(impulse, new CANNON.Vec3(0,0,0));
                }
            });
             console.log("BOOM! Explosion triggered at", explosionPos);
        }

        function activateParticles(position) {
            smokeParticles.position.copy(position);
            dustParticles.position.copy(position);
            smokeParticles.visible = true;
            dustParticles.visible = true;
            
            // Initialize smoke particles
            const smokePosAttr = smokeParticles.geometry.attributes.position;
            for(let i=0; i < smokePosAttr.count; i++) {
                const life = 3 + Math.random() * 3; // 3-6 seconds life
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 2
                );
                smokePosAttr.setXYZ(i, 0, 0, 0);
                smokePosAttr.array[i*3].velocity = velocity;
                smokePosAttr.array[i*3].life = life;
            }
            smokePosAttr.needsUpdate = true;
            
            // Initialize dust particles
            const dustPosAttr = dustParticles.geometry.attributes.position;
            for(let i=0; i < dustPosAttr.count; i++) {
                const life = 4 + Math.random() * 4; // 4-8 seconds life
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 1.5,
                    (Math.random() - 0.5) * 4
                );
                dustPosAttr.setXYZ(i, 0, 0, 0);
                dustPosAttr.array[i*3].velocity = velocity;
                dustPosAttr.array[i*3].life = life;
            }
            dustPosAttr.needsUpdate = true;
        }

        function updateParticles(dt) {
            if (!smokeParticles.visible) return;

            // Smoke
            const smokePosAttr = smokeParticles.geometry.attributes.position;
            for(let i=0; i < smokePosAttr.count; i++) {
                const life = smokePosAttr.array[i*3].life -= dt;
                if(life > 0) {
                    const velocity = smokePosAttr.array[i*3].velocity;
                    smokePosAttr.setXYZ(
                        i,
                        smokePosAttr.getX(i) + velocity.x * dt,
                        smokePosAttr.getY(i) + velocity.y * dt,
                        smokePosAttr.getZ(i) + velocity.z * dt
                    );
                    velocity.y -= 0.2 * dt; // Gravity effect
                } else {
                     smokePosAttr.setXYZ(i, 0, 0, 0); // Hide dead particles
                }
            }
            smokeParticles.material.opacity = Math.max(0, smokeParticles.material.opacity - dt * 0.2);
            smokePosAttr.needsUpdate = true;

            // Dust
            const dustPosAttr = dustParticles.geometry.attributes.position;
            for(let i=0; i < dustPosAttr.count; i++) {
                 const life = dustPosAttr.array[i*3].life -= dt;
                 if(life > 0) {
                    const velocity = dustPosAttr.array[i*3].velocity;
                     dustPosAttr.setXYZ(
                        i,
                        dustPosAttr.getX(i) + velocity.x * dt,
                        dustPosAttr.getY(i) + velocity.y * dt,
                        dustPosAttr.getZ(i) + velocity.z * dt
                    );
                 }
            }
            dustParticles.material.opacity = Math.max(0, dustParticles.material.opacity - dt * 0.15);
            dustPosAttr.needsUpdate = true;
        }

        let cameraMode = 0;
        function toggleCamera() {
            cameraMode = (cameraMode + 1) % 3;
            switch(cameraMode) {
                case 0: // Default view
                    controls.target.set(0, 15, 0);
                    camera.position.set(35, 20, 35);
                    break;
                case 1: // Top-down view
                    controls.target.set(0, 10, 0);
                    camera.position.set(0, 70, 10);
                    break;
                case 2: // Ground level view
                    controls.target.set(0, 5, -10);
                    camera.position.set(20, 5, 40);
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            
            if (explosion_triggered) {
                world.step(1/60, dt, 3);
            }

            // Sync physics and visuals
            for (const object of objectsToUpdate) {
                object.mesh.position.copy(object.body.position);
                object.mesh.quaternion.copy(object.body.quaternion);
            }

            // Update lighting and particles post-explosion
            if (explosion_triggered) {
                if (explosionLight.intensity > 0) {
                    explosionLight.intensity *= 0.95; // Fast decay for the flash
                }
                const ambient = scene.getObjectByProperty('isAmbientLight', true);
                const directional = scene.getObjectByProperty('isDirectionalLight', true);
                
                if (ambient.intensity < 1.5) { // Slowly restore light as dust settles
                    ambient.intensity += dt * 0.05;
                    directional.intensity += dt * 0.05;
                }
                updateParticles(dt);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>