<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då»ºç­‘æ‹†é™¤æ¼”ç¤º</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        .button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .button.explode {
            background: linear-gradient(45deg, #ff4757, #c44569);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(255, 71, 87, 0.6); }
            100% { box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3); }
        }
        
        .info {
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.5;
            opacity: 0.8;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">æ­£åœ¨åŠ è½½å»ºç­‘æ¨¡å‹...</div>
        <div id="controls">
            <button class="button explode" id="explodeBtn">å¼•çˆ†å»ºç­‘ ğŸ’¥</button>
            <button class="button" id="resetBtn">é‡ç½®åœºæ™¯ ğŸ”„</button>
            <button class="button" id="cameraBtn">åˆ‡æ¢è§†è§’ ğŸ“·</button>
            <div class="info">
                ğŸ–±ï¸ å·¦é”®ï¼šæ—‹è½¬è§†è§’<br>
                ğŸ–±ï¸ å³é”®ï¼šç§»åŠ¨è§†è§’<br>
                ğŸ–±ï¸ æ»šè½®ï¼šç¼©æ”¾è§†è§’
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.20.0/cannon.min.js"></script>

    <script>
        class BuildingDemolition {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.blocks = [];
                this.particles = [];
                this.explosionTriggered = false;
                this.cameraMode = 0; // 0: è‡ªç”±è§†è§’, 1: ä¾§è§†è§’, 2: ä¿¯è§†è§’
                
                // å»ºç­‘å‚æ•°
                this.BLOCKS_PER_LAYER = 20;
                this.BUILDING_HEIGHT = 60;
                this.BLOCK_SIZE = 1;
                this.BUILDING_RADIUS = this.BLOCKS_PER_LAYER / (2 * Math.PI);
                
                // é¼ æ ‡æ§åˆ¶
                this.mouseDown = false;
                this.mouseButton = 0;
                this.mouseX = 0;
                this.mouseY = 0;
                this.cameraRotation = { x: 0.3, y: 0 };
                this.cameraDistance = 50;
                this.cameraTarget = new THREE.Vector3(0, 30, 0);
                
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupPhysics();
                this.setupLighting();
                this.setupGround();
                this.buildStructure();
                this.setupControls();
                this.setupParticleSystem();
                this.animate();
                
                // éšè—åŠ è½½æç¤º
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }
            
            setupScene() {
                // åˆ›å»ºåœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // å¤©è“è‰²
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 200);
                
                // åˆ›å»ºç›¸æœº
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.updateCameraPosition();
                
                // åˆ›å»ºæ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // çª—å£è°ƒæ•´
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupPhysics() {
                // åˆ›å»ºç‰©ç†ä¸–ç•Œ
                this.world = new CANNON.World();
                this.world.gravity.set(0, -30, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 20;
                this.world.allowSleep = true;
                
                // åˆ›å»ºææ–™
                this.blockMaterial = new CANNON.Material("block");
                this.groundMaterial = new CANNON.Material("ground");
                
                // æ–¹å—é—´çš„æ¥è§¦ææ–™ï¼ˆé«˜æ‘©æ“¦åŠ›ï¼Œä½å¼¹æ€§ï¼‰
                this.blockContact = new CANNON.ContactMaterial(
                    this.blockMaterial, 
                    this.blockMaterial, 
                    {
                        friction: 0.9,
                        restitution: 0.02,
                        contactEquationStiffness: 1e8,
                        contactEquationRelaxation: 3
                    }
                );
                
                // æ–¹å—ä¸åœ°é¢çš„æ¥è§¦ææ–™
                this.blockGroundContact = new CANNON.ContactMaterial(
                    this.blockMaterial, 
                    this.groundMaterial, 
                    {
                        friction: 0.8,
                        restitution: 0.3
                    }
                );
                
                this.world.addContactMaterial(this.blockContact);
                this.world.addContactMaterial(this.blockGroundContact);
            }
            
            setupLighting() {
                // ç¯å¢ƒå…‰
                this.ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(this.ambientLight);
                
                // ä¸»å…‰æº
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.directionalLight.position.set(50, 80, 30);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 200;
                this.directionalLight.shadow.camera.left = -80;
                this.directionalLight.shadow.camera.right = 80;
                this.directionalLight.shadow.camera.top = 80;
                this.directionalLight.shadow.camera.bottom = -80;
                this.scene.add(this.directionalLight);
                
                // çˆ†ç‚¸å…‰æºï¼ˆåˆå§‹æ—¶å…³é—­ï¼‰
                this.explosionLight = new THREE.PointLight(0xff4500, 0, 50);
                this.explosionLight.position.set(this.BUILDING_RADIUS, 0.5, 0);
                this.scene.add(this.explosionLight);
            }
            
            setupGround() {
                // è§†è§‰åœ°é¢
                const groundGeometry = new THREE.PlaneGeometry(80, 80);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    roughness: 0.8
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // ç‰©ç†åœ°é¢
                const groundShape = new CANNON.Plane();
                this.groundBody = new CANNON.Body({ mass: 0, material: this.groundMaterial });
                this.groundBody.addShape(groundShape);
                this.groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.add(this.groundBody);
            }
            
            buildStructure() {
                this.blocks = [];
                const blockGeometry = new THREE.BoxGeometry(this.BLOCK_SIZE, this.BLOCK_SIZE, this.BLOCK_SIZE);
                
                // ç±³è‰²æè´¨ï¼Œæ·»åŠ ä¸€äº›çº¹ç†æ„Ÿ
                const blockMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xF5DEB3,
                    roughness: 0.7
                });
                
                for (let layer = 0; layer < this.BUILDING_HEIGHT; layer++) {
                    const layerOffset = (layer % 2) * (Math.PI / this.BLOCKS_PER_LAYER); // é”™å¼€50%
                    
                    for (let i = 0; i < this.BLOCKS_PER_LAYER; i++) {
                        const angle = (i / this.BLOCKS_PER_LAYER) * Math.PI * 2 + layerOffset;
                        
                        // ç¨å¾®å‡å°åŠå¾„ç¡®ä¿æ–¹å—é‡å ï¼Œåˆ›é€ ç´§å¯†è´´åˆçš„æ•ˆæœ
                        const radius = this.BUILDING_RADIUS - 0.1;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        const y = layer * this.BLOCK_SIZE + this.BLOCK_SIZE / 2;
                        
                        // åˆ›å»ºè§†è§‰æ–¹å—
                        const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial);
                        blockMesh.position.set(x, y, z);
                        blockMesh.castShadow = true;
                        blockMesh.receiveShadow = true;
                        this.scene.add(blockMesh);
                        
                        // åˆ›å»ºç‰©ç†æ–¹å—
                        const blockShape = new CANNON.Box(new CANNON.Vec3(
                            this.BLOCK_SIZE / 2, 
                            this.BLOCK_SIZE / 2, 
                            this.BLOCK_SIZE / 2
                        ));
                        const blockBody = new CANNON.Body({ 
                            mass: 1, 
                            material: this.blockMaterial,
                            sleepSpeedLimit: 0.1,
                            sleepTimeLimit: 1
                        });
                        blockBody.addShape(blockShape);
                        blockBody.position.set(x, y, z);
                        
                        // ç«‹å³è®©æ–¹å—è¿›å…¥ç¡çœ çŠ¶æ€
                        blockBody.sleep();
                        
                        this.world.add(blockBody);
                        
                        this.blocks.push({
                            mesh: blockMesh,
                            body: blockBody,
                            layer: layer,
                            index: i,
                            isExploded: false
                        });
                    }
                }
                
                // è®©ç‰©ç†ä¸–ç•Œç¨³å®š
                for (let i = 0; i < 120; i++) {
                    this.world.step(1/60);
                }
                
                // ç¡®ä¿æ‰€æœ‰æ–¹å—éƒ½ç¡çœ 
                this.blocks.forEach(block => {
                    block.body.sleep();
                });
            }
            
            setupParticleSystem() {
                // çƒŸé›¾ç²’å­ç³»ç»Ÿ
                this.smokeParticles = new THREE.Group();
                this.scene.add(this.smokeParticles);
                
                // ç°å°˜ç²’å­ç³»ç»Ÿ
                this.dustParticles = new THREE.Group();
                this.scene.add(this.dustParticles);
            }
            
            createExplosion() {
                if (this.explosionTriggered) return;
                this.explosionTriggered = true;
                
                // å”¤é†’æ‰€æœ‰æ–¹å—
                this.blocks.forEach(block => {
                    block.body.wakeUp();
                });
                
                // çˆ†ç‚¸å…‰æ•ˆ
                this.explosionLight.intensity = 3;
                this.ambientLight.intensity = 0.8;
                
                // æ‰¾åˆ°çˆ†ç‚¸ç‚¹é™„è¿‘çš„æ–¹å—ï¼ˆç¬¬1å±‚æœ€å³ä¾§ï¼‰
                const explosionPoint = new CANNON.Vec3(this.BUILDING_RADIUS, 0.5, 0);
                const explosionRadius = 2;
                const explosionForce = 15;
                
                // åˆ›å»ºçˆ†ç‚¸ç²’å­æ•ˆæœ
                this.createExplosionParticles(explosionPoint);
                
                // å¯¹çˆ†ç‚¸èŒƒå›´å†…çš„æ–¹å—æ–½åŠ å†²å‡»åŠ›
                this.blocks.forEach(block => {
                    const distance = block.body.position.distanceTo(explosionPoint);
                    if (distance <= explosionRadius) {
                        const forceDirection = new CANNON.Vec3();
                        block.body.position.vsub(explosionPoint, forceDirection);
                        forceDirection.normalize();
                        
                        // æ·»åŠ å‘ä¸Šçš„åˆ†é‡
                        forceDirection.y += 0.5;
                        forceDirection.normalize();
                        
                        const force = explosionForce * (1 - distance / explosionRadius);
                        forceDirection.scale(force * 100, forceDirection);
                        
                        block.body.applyImpulse(forceDirection, block.body.position);
                        block.isExploded = true;
                    }
                });
                
                // å…‰æ•ˆè¡°å‡
                setTimeout(() => {
                    this.explosionLight.intensity = 0;
                    this.ambientLight.intensity = 0.3; // çƒŸå°˜é®æŒ¡æ•ˆæœ
                }, 200);
                
                // æŒç»­åˆ›å»ºçƒŸå°˜æ•ˆæœ
                this.createContinuousSmoke();
            }
            
            createExplosionParticles(position) {
                const particleCount = 50;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.1, 0.8, Math.random() * 0.5 + 0.5),
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    
                    // éšæœºæ–¹å‘å’Œé€Ÿåº¦
                    const direction = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random(),
                        (Math.random() - 0.5) * 2
                    ).normalize();
                    
                    particle.velocity = direction.multiplyScalar(Math.random() * 10 + 5);
                    particle.life = 1.0;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                
                // ç²’å­åŠ¨ç”»
                const animateParticles = () => {
                    particles.forEach((particle, index) => {
                        particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
                        particle.velocity.y -= 0.3; // é‡åŠ›
                        particle.life -= 0.02;
                        particle.material.opacity = particle.life;
                        
                        if (particle.life <= 0) {
                            this.scene.remove(particle);
                            particles.splice(index, 1);
                        }
                    });
                    
                    if (particles.length > 0) {
                        requestAnimationFrame(animateParticles);
                    }
                };
                
                animateParticles();
            }
            
            createContinuousSmoke() {
                const smokeInterval = setInterval(() => {
                    if (this.smokeParticles.children.length > 100) {
                        clearInterval(smokeInterval);
                        return;
                    }
                    
                    for (let i = 0; i < 3; i++) {
                        const geometry = new THREE.SphereGeometry(Math.random() * 2 + 1, 8, 8);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x666666,
                            transparent: true,
                            opacity: Math.random() * 0.3 + 0.1
                        });
                        
                        const smoke = new THREE.Mesh(geometry, material);
                        smoke.position.set(
                            (Math.random() - 0.5) * 20,
                            Math.random() * 5,
                            (Math.random() - 0.5) * 20
                        );
                        
                        smoke.velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.5 + 0.2,
                            (Math.random() - 0.5) * 0.5
                        );
                        
                        smoke.life = Math.random() * 5 + 3;
                        this.smokeParticles.add(smoke);
                    }
                }, 100);
                
                // 5ç§’ååœæ­¢ç”ŸæˆçƒŸé›¾
                setTimeout(() => {
                    clearInterval(smokeInterval);
                }, 5000);
            }
            
            setupControls() {
                const explodeBtn = document.getElementById('explodeBtn');
                const resetBtn = document.getElementById('resetBtn');
                const cameraBtn = document.getElementById('cameraBtn');
                
                explodeBtn.addEventListener('click', () => {
                    this.createExplosion();
                    explodeBtn.disabled = true;
                    explodeBtn.textContent = 'å·²å¼•çˆ† âœ…';
                });
                
                resetBtn.addEventListener('click', () => {
                    this.reset();
                });
                
                cameraBtn.addEventListener('click', () => {
                    this.switchCamera();
                });
                
                // é¼ æ ‡æ§åˆ¶
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    this.mouseDown = true;
                    this.mouseButton = e.button;
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    e.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    this.mouseDown = false;
                });
                
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (!this.mouseDown) return;
                    
                    const deltaX = e.clientX - this.mouseX;
                    const deltaY = e.clientY - this.mouseY;
                    
                    if (this.mouseButton === 0) { // å·¦é”® - æ—‹è½¬
                        this.cameraRotation.y -= deltaX * 0.01;
                        this.cameraRotation.x -= deltaY * 0.01;
                        this.cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotation.x));
                    } else if (this.mouseButton === 2) { // å³é”® - å¹³ç§»
                        const factor = this.cameraDistance * 0.001;
                        this.cameraTarget.x += deltaX * factor;
                        this.cameraTarget.y -= deltaY * factor;
                    }
                    
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    this.updateCameraPosition();
                });
                
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    this.cameraDistance += e.deltaY * 0.01;
                    this.cameraDistance = Math.max(10, Math.min(100, this.cameraDistance));
                    this.updateCameraPosition();
                    e.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            updateCameraPosition() {
                if (this.cameraMode === 0) { // è‡ªç”±è§†è§’
                    const x = Math.cos(this.cameraRotation.x) * Math.cos(this.cameraRotation.y) * this.cameraDistance;
                    const y = Math.sin(this.cameraRotation.x) * this.cameraDistance;
                    const z = Math.cos(this.cameraRotation.x) * Math.sin(this.cameraRotation.y) * this.cameraDistance;
                    
                    this.camera.position.set(
                        this.cameraTarget.x + x,
                        this.cameraTarget.y + y,
                        this.cameraTarget.z + z
                    );
                    this.camera.lookAt(this.cameraTarget);
                }
            }
            
            switchCamera() {
                this.cameraMode = (this.cameraMode + 1) % 3;
                
                switch (this.cameraMode) {
                    case 0: // è‡ªç”±è§†è§’
                        this.updateCameraPosition();
                        break;
                    case 1: // ä¾§è§†è§’
                        this.camera.position.set(60, 30, 0);
                        this.camera.lookAt(0, 30, 0);
                        break;
                    case 2: // ä¿¯è§†è§’
                        this.camera.position.set(0, 80, 30);
                        this.camera.lookAt(0, 0, 0);
                        break;
                }
            }
            
            reset() {
                // æ¸…ç©ºåœºæ™¯
                this.blocks.forEach(block => {
                    this.scene.remove(block.mesh);
                    this.world.remove(block.body);
                });
                
                // æ¸…ç©ºç²’å­
                this.smokeParticles.clear();
                this.dustParticles.clear();
                
                // é‡ç½®çŠ¶æ€
                this.explosionTriggered = false;
                this.ambientLight.intensity = 0.4;
                this.explosionLight.intensity = 0;
                
                // é‡æ–°æ„å»ºå»ºç­‘
                this.buildStructure();
                
                // é‡ç½®æŒ‰é’®
                const explodeBtn = document.getElementById('explodeBtn');
                explodeBtn.disabled = false;
                explodeBtn.textContent = 'å¼•çˆ†å»ºç­‘ ğŸ’¥';
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // æ›´æ–°ç‰©ç†ä¸–ç•Œ
                this.world.step(1/60);
                
                // åŒæ­¥è§†è§‰å’Œç‰©ç†
                this.blocks.forEach(block => {
                    block.mesh.position.copy(block.body.position);
                    block.mesh.quaternion.copy(block.body.quaternion);
                });
                
                // æ›´æ–°çƒŸé›¾ç²’å­
                this.smokeParticles.children.forEach((smoke, index) => {
                    smoke.position.add(smoke.velocity);
                    smoke.life -= 0.016;
                    smoke.material.opacity *= 0.99;
                    smoke.scale.multiplyScalar(1.01);
                    
                    if (smoke.life <= 0 || smoke.material.opacity < 0.01) {
                        this.smokeParticles.remove(smoke);
                    }
                });
                
                // æ¸²æŸ“åœºæ™¯
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // å¯åŠ¨æ¼”ç¤º
        window.addEventListener('DOMContentLoaded', () => {
            new BuildingDemolition();
        });
    </script>
</body>
</html>