<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D建筑拆除演示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        
        .button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        .button.explode {
            background: linear-gradient(45deg, #ff4757, #c44569);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3); }
            50% { box-shadow: 0 4px 25px rgba(255, 71, 87, 0.6); }
            100% { box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3); }
        }
        
        .info {
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.5;
            opacity: 0.8;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">正在加载建筑模型...</div>
        <div id="controls">
            <button class="button explode" id="explodeBtn">引爆建筑 💥</button>
            <button class="button" id="resetBtn">重置场景 🔄</button>
            <button class="button" id="cameraBtn">切换视角 📷</button>
            <div class="info">
                🖱️ 左键：旋转视角<br>
                🖱️ 右键：移动视角<br>
                🖱️ 滚轮：缩放视角
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.20.0/cannon.min.js"></script>

    <script>
        class BuildingDemolition {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.blocks = [];
                this.particles = [];
                this.explosionTriggered = false;
                this.cameraMode = 0; // 0: 自由视角, 1: 侧视角, 2: 俯视角
                
                // 建筑参数
                this.BLOCKS_PER_LAYER = 20;
                this.BUILDING_HEIGHT = 60;
                this.BLOCK_SIZE = 1;
                this.BUILDING_RADIUS = this.BLOCKS_PER_LAYER / (2 * Math.PI);
                
                // 鼠标控制
                this.mouseDown = false;
                this.mouseButton = 0;
                this.mouseX = 0;
                this.mouseY = 0;
                this.cameraRotation = { x: 0.3, y: 0 };
                this.cameraDistance = 50;
                this.cameraTarget = new THREE.Vector3(0, 30, 0);
                
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupPhysics();
                this.setupLighting();
                this.setupGround();
                this.buildStructure();
                this.setupControls();
                this.setupParticleSystem();
                this.animate();
                
                // 隐藏加载提示
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }
            
            setupScene() {
                // 创建场景
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // 天蓝色
                this.scene.fog = new THREE.Fog(0x87CEEB, 100, 200);
                
                // 创建相机
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.updateCameraPosition();
                
                // 创建渲染器
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.outputEncoding = THREE.sRGBEncoding;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.0;
                
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // 窗口调整
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupPhysics() {
                // 创建物理世界
                this.world = new CANNON.World();
                this.world.gravity.set(0, -30, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 20;
                this.world.allowSleep = true;
                
                // 创建材料
                this.blockMaterial = new CANNON.Material("block");
                this.groundMaterial = new CANNON.Material("ground");
                
                // 方块间的接触材料（高摩擦力，低弹性）
                this.blockContact = new CANNON.ContactMaterial(
                    this.blockMaterial, 
                    this.blockMaterial, 
                    {
                        friction: 0.9,
                        restitution: 0.02,
                        contactEquationStiffness: 1e8,
                        contactEquationRelaxation: 3
                    }
                );
                
                // 方块与地面的接触材料
                this.blockGroundContact = new CANNON.ContactMaterial(
                    this.blockMaterial, 
                    this.groundMaterial, 
                    {
                        friction: 0.8,
                        restitution: 0.3
                    }
                );
                
                this.world.addContactMaterial(this.blockContact);
                this.world.addContactMaterial(this.blockGroundContact);
            }
            
            setupLighting() {
                // 环境光
                this.ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(this.ambientLight);
                
                // 主光源
                this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.directionalLight.position.set(50, 80, 30);
                this.directionalLight.castShadow = true;
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 200;
                this.directionalLight.shadow.camera.left = -80;
                this.directionalLight.shadow.camera.right = 80;
                this.directionalLight.shadow.camera.top = 80;
                this.directionalLight.shadow.camera.bottom = -80;
                this.scene.add(this.directionalLight);
                
                // 爆炸光源（初始时关闭）
                this.explosionLight = new THREE.PointLight(0xff4500, 0, 50);
                this.explosionLight.position.set(this.BUILDING_RADIUS, 0.5, 0);
                this.scene.add(this.explosionLight);
            }
            
            setupGround() {
                // 视觉地面
                const groundGeometry = new THREE.PlaneGeometry(80, 80);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    roughness: 0.8
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // 物理地面
                const groundShape = new CANNON.Plane();
                this.groundBody = new CANNON.Body({ mass: 0, material: this.groundMaterial });
                this.groundBody.addShape(groundShape);
                this.groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.add(this.groundBody);
            }
            
            buildStructure() {
                this.blocks = [];
                const blockGeometry = new THREE.BoxGeometry(this.BLOCK_SIZE, this.BLOCK_SIZE, this.BLOCK_SIZE);
                
                // 米色材质，添加一些纹理感
                const blockMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xF5DEB3,
                    roughness: 0.7
                });
                
                for (let layer = 0; layer < this.BUILDING_HEIGHT; layer++) {
                    const layerOffset = (layer % 2) * (Math.PI / this.BLOCKS_PER_LAYER); // 错开50%
                    
                    for (let i = 0; i < this.BLOCKS_PER_LAYER; i++) {
                        const angle = (i / this.BLOCKS_PER_LAYER) * Math.PI * 2 + layerOffset;
                        
                        // 稍微减小半径确保方块重叠，创造紧密贴合的效果
                        const radius = this.BUILDING_RADIUS - 0.1;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        const y = layer * this.BLOCK_SIZE + this.BLOCK_SIZE / 2;
                        
                        // 创建视觉方块
                        const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial);
                        blockMesh.position.set(x, y, z);
                        blockMesh.castShadow = true;
                        blockMesh.receiveShadow = true;
                        this.scene.add(blockMesh);
                        
                        // 创建物理方块
                        const blockShape = new CANNON.Box(new CANNON.Vec3(
                            this.BLOCK_SIZE / 2, 
                            this.BLOCK_SIZE / 2, 
                            this.BLOCK_SIZE / 2
                        ));
                        const blockBody = new CANNON.Body({ 
                            mass: 1, 
                            material: this.blockMaterial,
                            sleepSpeedLimit: 0.1,
                            sleepTimeLimit: 1
                        });
                        blockBody.addShape(blockShape);
                        blockBody.position.set(x, y, z);
                        
                        // 立即让方块进入睡眠状态
                        blockBody.sleep();
                        
                        this.world.add(blockBody);
                        
                        this.blocks.push({
                            mesh: blockMesh,
                            body: blockBody,
                            layer: layer,
                            index: i,
                            isExploded: false
                        });
                    }
                }
                
                // 让物理世界稳定
                for (let i = 0; i < 120; i++) {
                    this.world.step(1/60);
                }
                
                // 确保所有方块都睡眠
                this.blocks.forEach(block => {
                    block.body.sleep();
                });
            }
            
            setupParticleSystem() {
                // 烟雾粒子系统
                this.smokeParticles = new THREE.Group();
                this.scene.add(this.smokeParticles);
                
                // 灰尘粒子系统
                this.dustParticles = new THREE.Group();
                this.scene.add(this.dustParticles);
            }
            
            createExplosion() {
                if (this.explosionTriggered) return;
                this.explosionTriggered = true;
                
                // 唤醒所有方块
                this.blocks.forEach(block => {
                    block.body.wakeUp();
                });
                
                // 爆炸光效
                this.explosionLight.intensity = 3;
                this.ambientLight.intensity = 0.8;
                
                // 找到爆炸点附近的方块（第1层最右侧）
                const explosionPoint = new CANNON.Vec3(this.BUILDING_RADIUS, 0.5, 0);
                const explosionRadius = 2;
                const explosionForce = 15;
                
                // 创建爆炸粒子效果
                this.createExplosionParticles(explosionPoint);
                
                // 对爆炸范围内的方块施加冲击力
                this.blocks.forEach(block => {
                    const distance = block.body.position.distanceTo(explosionPoint);
                    if (distance <= explosionRadius) {
                        const forceDirection = new CANNON.Vec3();
                        block.body.position.vsub(explosionPoint, forceDirection);
                        forceDirection.normalize();
                        
                        // 添加向上的分量
                        forceDirection.y += 0.5;
                        forceDirection.normalize();
                        
                        const force = explosionForce * (1 - distance / explosionRadius);
                        forceDirection.scale(force * 100, forceDirection);
                        
                        block.body.applyImpulse(forceDirection, block.body.position);
                        block.isExploded = true;
                    }
                });
                
                // 光效衰减
                setTimeout(() => {
                    this.explosionLight.intensity = 0;
                    this.ambientLight.intensity = 0.3; // 烟尘遮挡效果
                }, 200);
                
                // 持续创建烟尘效果
                this.createContinuousSmoke();
            }
            
            createExplosionParticles(position) {
                const particleCount = 50;
                const particles = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.1, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(0.1, 0.8, Math.random() * 0.5 + 0.5),
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    
                    // 随机方向和速度
                    const direction = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random(),
                        (Math.random() - 0.5) * 2
                    ).normalize();
                    
                    particle.velocity = direction.multiplyScalar(Math.random() * 10 + 5);
                    particle.life = 1.0;
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                
                // 粒子动画
                const animateParticles = () => {
                    particles.forEach((particle, index) => {
                        particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
                        particle.velocity.y -= 0.3; // 重力
                        particle.life -= 0.02;
                        particle.material.opacity = particle.life;
                        
                        if (particle.life <= 0) {
                            this.scene.remove(particle);
                            particles.splice(index, 1);
                        }
                    });
                    
                    if (particles.length > 0) {
                        requestAnimationFrame(animateParticles);
                    }
                };
                
                animateParticles();
            }
            
            createContinuousSmoke() {
                const smokeInterval = setInterval(() => {
                    if (this.smokeParticles.children.length > 100) {
                        clearInterval(smokeInterval);
                        return;
                    }
                    
                    for (let i = 0; i < 3; i++) {
                        const geometry = new THREE.SphereGeometry(Math.random() * 2 + 1, 8, 8);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x666666,
                            transparent: true,
                            opacity: Math.random() * 0.3 + 0.1
                        });
                        
                        const smoke = new THREE.Mesh(geometry, material);
                        smoke.position.set(
                            (Math.random() - 0.5) * 20,
                            Math.random() * 5,
                            (Math.random() - 0.5) * 20
                        );
                        
                        smoke.velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.5 + 0.2,
                            (Math.random() - 0.5) * 0.5
                        );
                        
                        smoke.life = Math.random() * 5 + 3;
                        this.smokeParticles.add(smoke);
                    }
                }, 100);
                
                // 5秒后停止生成烟雾
                setTimeout(() => {
                    clearInterval(smokeInterval);
                }, 5000);
            }
            
            setupControls() {
                const explodeBtn = document.getElementById('explodeBtn');
                const resetBtn = document.getElementById('resetBtn');
                const cameraBtn = document.getElementById('cameraBtn');
                
                explodeBtn.addEventListener('click', () => {
                    this.createExplosion();
                    explodeBtn.disabled = true;
                    explodeBtn.textContent = '已引爆 ✅';
                });
                
                resetBtn.addEventListener('click', () => {
                    this.reset();
                });
                
                cameraBtn.addEventListener('click', () => {
                    this.switchCamera();
                });
                
                // 鼠标控制
                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    this.mouseDown = true;
                    this.mouseButton = e.button;
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    e.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    this.mouseDown = false;
                });
                
                this.renderer.domElement.addEventListener('mousemove', (e) => {
                    if (!this.mouseDown) return;
                    
                    const deltaX = e.clientX - this.mouseX;
                    const deltaY = e.clientY - this.mouseY;
                    
                    if (this.mouseButton === 0) { // 左键 - 旋转
                        this.cameraRotation.y -= deltaX * 0.01;
                        this.cameraRotation.x -= deltaY * 0.01;
                        this.cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotation.x));
                    } else if (this.mouseButton === 2) { // 右键 - 平移
                        const factor = this.cameraDistance * 0.001;
                        this.cameraTarget.x += deltaX * factor;
                        this.cameraTarget.y -= deltaY * factor;
                    }
                    
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    this.updateCameraPosition();
                });
                
                this.renderer.domElement.addEventListener('wheel', (e) => {
                    this.cameraDistance += e.deltaY * 0.01;
                    this.cameraDistance = Math.max(10, Math.min(100, this.cameraDistance));
                    this.updateCameraPosition();
                    e.preventDefault();
                });
                
                this.renderer.domElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            updateCameraPosition() {
                if (this.cameraMode === 0) { // 自由视角
                    const x = Math.cos(this.cameraRotation.x) * Math.cos(this.cameraRotation.y) * this.cameraDistance;
                    const y = Math.sin(this.cameraRotation.x) * this.cameraDistance;
                    const z = Math.cos(this.cameraRotation.x) * Math.sin(this.cameraRotation.y) * this.cameraDistance;
                    
                    this.camera.position.set(
                        this.cameraTarget.x + x,
                        this.cameraTarget.y + y,
                        this.cameraTarget.z + z
                    );
                    this.camera.lookAt(this.cameraTarget);
                }
            }
            
            switchCamera() {
                this.cameraMode = (this.cameraMode + 1) % 3;
                
                switch (this.cameraMode) {
                    case 0: // 自由视角
                        this.updateCameraPosition();
                        break;
                    case 1: // 侧视角
                        this.camera.position.set(60, 30, 0);
                        this.camera.lookAt(0, 30, 0);
                        break;
                    case 2: // 俯视角
                        this.camera.position.set(0, 80, 30);
                        this.camera.lookAt(0, 0, 0);
                        break;
                }
            }
            
            reset() {
                // 清空场景
                this.blocks.forEach(block => {
                    this.scene.remove(block.mesh);
                    this.world.remove(block.body);
                });
                
                // 清空粒子
                this.smokeParticles.clear();
                this.dustParticles.clear();
                
                // 重置状态
                this.explosionTriggered = false;
                this.ambientLight.intensity = 0.4;
                this.explosionLight.intensity = 0;
                
                // 重新构建建筑
                this.buildStructure();
                
                // 重置按钮
                const explodeBtn = document.getElementById('explodeBtn');
                explodeBtn.disabled = false;
                explodeBtn.textContent = '引爆建筑 💥';
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // 更新物理世界
                this.world.step(1/60);
                
                // 同步视觉和物理
                this.blocks.forEach(block => {
                    block.mesh.position.copy(block.body.position);
                    block.mesh.quaternion.copy(block.body.quaternion);
                });
                
                // 更新烟雾粒子
                this.smokeParticles.children.forEach((smoke, index) => {
                    smoke.position.add(smoke.velocity);
                    smoke.life -= 0.016;
                    smoke.material.opacity *= 0.99;
                    smoke.scale.multiplyScalar(1.01);
                    
                    if (smoke.life <= 0 || smoke.material.opacity < 0.01) {
                        this.smokeParticles.remove(smoke);
                    }
                });
                
                // 渲染场景
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // 启动演示
        window.addEventListener('DOMContentLoaded', () => {
            new BuildingDemolition();
        });
    </script>
</body>
</html>