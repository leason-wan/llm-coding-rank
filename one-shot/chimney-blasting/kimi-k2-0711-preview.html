<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D建筑拆除演示</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }
        
        button {
            display: block;
            width: 150px;
            margin: 10px 0;
            padding: 10px;
            background: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #555;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #explode-btn {
            background: #cc0000;
            font-weight: bold;
        }
        
        #explode-btn:hover:not(:disabled) {
            background: #ff0000;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="controls">
            <h3>建筑拆除控制面板</h3>
            <button id="explode-btn">引爆</button>
            <button id="reset-btn">重置场景</button>
            <button id="camera-btn">切换视角</button>
        </div>
        <div id="info">
            鼠标左键：旋转视角 | 右键：平移视角 | 滚轮：缩放
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        // 全局变量
        let scene, camera, renderer, world;
        let buildingBlocks = [];
        let particles = [];
        let smokeParticles = [];
        let explosionLight;
        let isExploded = false;
        let cameraMode = 0;
        
        // 建筑参数
        const BLOCK_SIZE = 1;
        const BUILDING_RADIUS = 10;
        const BUILDING_HEIGHT = 60;
        const BLOCKS_PER_LAYER = 20;
        
        // 初始化Three.js场景
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xcccccc, 50, 200);
            
            // 相机设置
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(30, 30, 30);
            camera.lookAt(0, 0, 0);
            
            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // 光照
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 爆炸光源（初始关闭）
            explosionLight = new THREE.PointLight(0xff6600, 0, 50);
            explosionLight.position.set(0, 0, 0);
            scene.add(explosionLight);
            
            // 地面
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        // 初始化Cannon.js物理世界
        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            
            // 地面物理体
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape
            });
            groundBody.quaternion.setFromAxisAngle(
                new CANNON.Vec3(1, 0, 0),
                -Math.PI / 2
            );
            world.add(groundBody);
            
            // 创建砖块间的接触材料
            const blockMaterial = new CANNON.Material('block');
            const blockContactMaterial = new CANNON.ContactMaterial(
                blockMaterial,
                blockMaterial,
                {
                    friction: 0.9,
                    restitution: 0.05,
                    contactEquationStiffness: 1e8,
                    contactEquationRelaxation: 3
                }
            );
            world.addContactMaterial(blockContactMaterial);
            
            return blockMaterial;
        }
        
        // 创建建筑
        function createBuilding(blockMaterial) {
            const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE * 0.98, BLOCK_SIZE * 0.98, BLOCK_SIZE * 0.98);
            const blockMaterialThree = new THREE.MeshLambertMaterial({ color: 0xd4c5a9 });
            
            for (let layer = 0; layer < BUILDING_HEIGHT; layer++) {
                const y = layer * BLOCK_SIZE + BLOCK_SIZE / 2;
                const angleStep = (Math.PI * 2) / BLOCKS_PER_LAYER;
                
                for (let i = 0; i < BLOCKS_PER_LAYER; i++) {
                    const angle = i * angleStep + (layer % 2) * (angleStep / 2);
                    const x = Math.cos(angle) * BUILDING_RADIUS;
                    const z = Math.sin(angle) * BUILDING_RADIUS;
                    
                    // Three.js网格
                    const block = new THREE.Mesh(blockGeometry, blockMaterialThree);
                    block.position.set(x, y, z);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    scene.add(block);
                    
                    // Cannon.js物理体
                    const shape = new CANNON.Box(new CANNON.Vec3(BLOCK_SIZE/2, BLOCK_SIZE/2, BLOCK_SIZE/2));
                    const body = new CANNON.Body({
                        mass: 1,
                        shape: shape,
                        material: blockMaterial
                    });
                    body.position.set(x, y, z);
                    
                    // 设置初始睡眠状态
                    body.sleep();
                    body.allowSleep = true;
                    
                    world.add(body);
                    
                    buildingBlocks.push({ mesh: block, body: body });
                }
            }
            
            // 让物理世界稳定几帧
            for (let i = 0; i < 10; i++) {
                world.step(1/60);
            }
        }
        
        // 创建粒子系统
        function createParticleSystem() {
            // 烟雾粒子
            const smokeGeometry = new THREE.BufferGeometry();
            const smokeMaterial = new THREE.PointsMaterial({
                color: 0x666666,
                size: 0.5,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const smokePositions = new Float32Array(1000 * 3);
            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
            
            const smokeSystem = new THREE.Points(smokeGeometry, smokeMaterial);
            scene.add(smokeSystem);
            smokeParticles.push({ system: smokeSystem, positions: smokePositions });
        }
        
        // 爆炸效果
        function explode() {
            if (isExploded) return;
            isExploded = true;
            
            // 禁用爆炸按钮
            document.getElementById('explode-btn').disabled = true;
            
            // 爆炸位置（第一层最右侧）
            const explosionPos = new THREE.Vector3(BUILDING_RADIUS, BLOCK_SIZE/2, 0);
            
            // 唤醒所有方块
            buildingBlocks.forEach(block => {
                block.body.wakeUp();
            });
            
            // 爆炸冲击波
            buildingBlocks.forEach(block => {
                const distance = block.body.position.distanceTo(new CANNON.Vec3(explosionPos.x, explosionPos.y, explosionPos.z));
                if (distance < 2) {
                    const force = new CANNON.Vec3(
                        (block.body.position.x - explosionPos.x) * 5,
                        3,
                        (block.body.position.z - explosionPos.z) * 5
                    );
                    block.body.applyImpulse(force, block.body.position);
                }
            });
            
            // 爆炸光照效果
            explosionLight.position.copy(explosionPos);
            explosionLight.intensity = 10;
            
            // 创建爆炸粒子
            createExplosionParticles(explosionPos);
            
            // 光照衰减
            setTimeout(() => {
                const fadeOut = setInterval(() => {
                    explosionLight.intensity *= 0.9;
                    if (explosionLight.intensity < 0.1) {
                        explosionLight.intensity = 0;
                        clearInterval(fadeOut);
                    }
                }, 50);
            }, 100);
            
            // 创建烟雾
            createSmoke(explosionPos);
        }
        
        // 创建爆炸粒子
        function createExplosionParticles(position) {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities.push({
                    x: (Math.random() - 0.5) * 20,
                    y: Math.random() * 10 + 5,
                    z: (Math.random() - 0.5) * 20
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xff6600,
                size: 0.3,
                transparent: true,
                opacity: 1
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            particles.push({
                system: particleSystem,
                positions: positions,
                velocities: velocities,
                life: 1.0
            });
        }
        
        // 创建烟雾
        function createSmoke(position) {
            const smokeCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(smokeCount * 3);
            
            for (let i = 0; i < smokeCount; i++) {
                positions[i * 3] = position.x + (Math.random() - 0.5) * 10;
                positions[i * 3 + 1] = position.y + Math.random() * 5;
                positions[i * 3 + 2] = position.z + (Math.random() - 0.5) * 10;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x444444,
                size: 1,
                transparent: true,
                opacity: 0.5
            });
            
            const smoke = new THREE.Points(geometry, material);
            scene.add(smoke);
            
            // 烟雾上升动画
            let smokeLife = 1.0;
            const smokeInterval = setInterval(() => {
                const positions = smoke.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += 0.1;
                    positions[i] += (Math.random() - 0.5) * 0.1;
                    positions[i + 2] += (Math.random() - 0.5) * 0.1;
                }
                smoke.geometry.attributes.position.needsUpdate = true;
                
                smokeLife -= 0.01;
                smoke.material.opacity = smokeLife * 0.5;
                
                if (smokeLife <= 0) {
                    scene.remove(smoke);
                    clearInterval(smokeInterval);
                }
            }, 50);
        }
        
        // 更新粒子
        function updateParticles() {
            particles.forEach((particle, index) => {
                const positions = particle.positions;
                const velocities = particle.velocities;
                
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3] += velocities[i].x * 0.016;
                    positions[i * 3 + 1] += velocities[i].y * 0.016;
                    positions[i * 3 + 2] += velocities[i].z * 0.016;
                    
                    velocities[i].y -= 9.8 * 0.016;
                }
                
                particle.system.geometry.attributes.position.needsUpdate = true;
                
                particle.life -= 0.02;
                particle.system.material.opacity = particle.life;
                
                if (particle.life <= 0) {
                    scene.remove(particle.system);
                    particles.splice(index, 1);
                }
            });
        }
        
        // 相机控制
        let mouseX = 0, mouseY = 0;
        let targetX = 0, targetY = 0;
        let isMouseDown = false;
        let isRightMouseDown = false;
        
        function initControls() {
            // 鼠标控制
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) isMouseDown = true;
                if (e.button === 2) isRightMouseDown = true;
            });
            
            renderer.domElement.addEventListener('mouseup', (e) => {
                if (e.button === 0) isMouseDown = false;
                if (e.button === 2) isRightMouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    targetX += e.movementX * 0.5;
                    targetY += e.movementY * 0.5;
                    targetY = Math.max(-89, Math.min(89, targetY));
                }
                if (isRightMouseDown) {
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    const right = new THREE.Vector3();
                    right.crossVectors(camera.up, forward).normalize();
                    camera.position.addScaledVector(right, -e.movementX * 0.1);
                    camera.position.y += e.movementY * 0.1;
                }
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
            });
            
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // 按钮事件
            document.getElementById('explode-btn').addEventListener('click', explode);
            document.getElementById('reset-btn').addEventListener('click', resetScene);
            document.getElementById('camera-btn').addEventListener('click', switchCamera);
        }
        
        // 切换相机视角
        function switchCamera() {
            cameraMode = (cameraMode + 1) % 3;
            switch(cameraMode) {
                case 0:
                    camera.position.set(30, 30, 30);
                    camera.lookAt(0, 0, 0);
                    break;
                case 1:
                    camera.position.set(0, 50, 50);
                    camera.lookAt(0, 20, 0);
                    break;
                case 2:
                    camera.position.set(50, 10, 0);
                    camera.lookAt(0, 20, 0);
                    break;
            }
        }
        
        // 重置场景
        function resetScene() {
            // 清除所有物体
            buildingBlocks.forEach(block => {
                scene.remove(block.mesh);
                world.remove(block.body);
            });
            buildingBlocks = [];
            
            particles.forEach(particle => {
                scene.remove(particle.system);
            });
            particles = [];
            
            // 重置状态
            isExploded = false;
            explosionLight.intensity = 0;
            document.getElementById('explode-btn').disabled = false;
            
            // 重新创建建筑
            const blockMaterial = initPhysics();
            createBuilding(blockMaterial);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新物理世界
            world.step(1/60);
            
            // 同步物理和渲染
            buildingBlocks.forEach(block => {
                block.mesh.position.copy(block.body.position);
                block.mesh.quaternion.copy(block.body.quaternion);
            });
            
            // 更新粒子
            updateParticles();
            
            // 平滑相机旋转
            if (!isMouseDown && !isRightMouseDown) {
                mouseX += (targetX - mouseX) * 0.05;
                mouseY += (targetY - mouseY) * 0.05;
                
                const radius = camera.position.length();
                camera.position.x = radius * Math.sin(mouseX * Math.PI / 180) * Math.cos(mouseY * Math.PI / 180);
                camera.position.y = radius * Math.sin(mouseY * Math.PI / 180);
                camera.position.z = radius * Math.cos(mouseX * Math.PI / 180) * Math.cos(mouseY * Math.PI / 180);
                camera.lookAt(0, 20, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 初始化
        initThree();
        const blockMaterial = initPhysics();
        createBuilding(blockMaterial);
        createParticleSystem();
        initControls();
        animate();
    </script>
</body>
</html>