<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éœ‡æ’¼3Då»ºç­‘æ‹†é™¤æ¼”ç¤º</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b35, #f7931e);
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        #explodeBtn {
            background: linear-gradient(45deg, #ff1744, #d50000);
            font-size: 16px;
            padding: 15px 30px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 23, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 23, 68, 0); }
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">æ­£åœ¨æ„å»ºå»ºç­‘ç‰©...</div>
        
        <div id="controls">
            <div class="control-group">
                <button id="explodeBtn" disabled>ğŸ’¥ å¼•çˆ†å»ºç­‘</button>
            </div>
            <div class="control-group">
                <button id="resetBtn">ğŸ”„ é‡ç½®åœºæ™¯</button>
                <button id="cameraBtn">ğŸ“· åˆ‡æ¢è§†è§’</button>
            </div>
            <div class="control-group">
                <small>é¼ æ ‡å·¦é”®ï¼šæ—‹è½¬è§†è§’</small><br>
                <small>é¼ æ ‡å³é”®ï¼šç§»åŠ¨ä½ç½®</small><br>
                <small>æ»šè½®ï¼šç¼©æ”¾</small>
            </div>
        </div>
        
        <div id="info">
            ç‰©ç†æ–¹å—æ•°é‡: <span id="blockCount">0</span><br>
            å»ºç­‘çŠ¶æ€: <span id="buildingStatus">æ„å»ºä¸­</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        
    <script type="module">
        import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

        class BuildingDemolition {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.world = null;
                this.blocks = [];
                this.ground = null;
                this.exploded = false;
                this.cameraMode = 0;
                this.cameraPositions = [
                    { pos: [50, 30, 50], target: [0, 25, 0] },
                    { pos: [0, 80, 80], target: [0, 30, 0] },
                    { pos: [-60, 25, 0], target: [0, 25, 0] },
                    { pos: [30, 15, 30], target: [0, 25, 0] }
                ];
                
                // ç²’å­ç³»ç»Ÿ
                this.particleSystem = null;
                this.smokeParticles = [];
                this.dustParticles = [];
                
                // æ§åˆ¶
                this.mouseDown = false;
                this.mouseButton = 0;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.init();
            }
            
            init() {
                this.setupScene();
                this.setupPhysics();
                this.setupLighting();
                this.setupControls();
                this.createGround();
                this.createBuilding();
                this.setupParticleSystem();
                this.animate();
                
                // å»¶è¿Ÿå¯ç”¨çˆ†ç‚¸æŒ‰é’®
                setTimeout(() => {
                    document.getElementById('explodeBtn').disabled = false;
                    document.getElementById('buildingStatus').textContent = 'ç¨³å®š';
                    document.getElementById('loading').style.display = 'none';
                }, 3000);
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                this.scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
                
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(50, 30, 50);
                this.camera.lookAt(0, 25, 0);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x87CEEB, 1);
                
                document.getElementById('container').appendChild(this.renderer.domElement);
            }
            
            setupPhysics() {
                this.world = new CANNON.World();
                this.world.gravity.set(0, -30, 0);
                this.world.broadphase = new CANNON.NaiveBroadphase();
                this.world.solver.iterations = 10;
                this.world.allowSleep = true;
                
                // åˆ›å»ºææ–™
                this.concreteMaterial = new CANNON.Material('concrete');
                this.brickMaterial = new CANNON.Material('brick');
                
                // è®¾ç½®æ¥è§¦ææ–™ - é«˜æ‘©æ“¦åŠ›ï¼Œä½å¼¹æ€§
                const concreteContact = new CANNON.ContactMaterial(
                    this.concreteMaterial,
                    this.concreteMaterial,
                    { friction: 0.9, restitution: 0.02 }
                );
                
                const brickContact = new CANNON.ContactMaterial(
                    this.brickMaterial,
                    this.brickMaterial,
                    { friction: 0.85, restitution: 0.03 }
                );
                
                const brickConcreteContact = new CANNON.ContactMaterial(
                    this.brickMaterial,
                    this.concreteMaterial,
                    { friction: 0.8, restitution: 0.02 }
                );
                
                this.world.addContactMaterial(concreteContact);
                this.world.addContactMaterial(brickContact);
                this.world.addContactMaterial(brickConcreteContact);
            }
            
            setupLighting() {
                // ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                // ä¸»å…‰æº
                this.mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                this.mainLight.position.set(50, 100, 50);
                this.mainLight.castShadow = true;
                this.mainLight.shadow.mapSize.width = 2048;
                this.mainLight.shadow.mapSize.height = 2048;
                this.mainLight.shadow.camera.near = 0.5;
                this.mainLight.shadow.camera.far = 200;
                this.mainLight.shadow.camera.left = -50;
                this.mainLight.shadow.camera.right = 50;
                this.mainLight.shadow.camera.top = 50;
                this.mainLight.shadow.camera.bottom = -50;
                this.scene.add(this.mainLight);
                
                // è¡¥å……å…‰æº
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight.position.set(-30, 50, -30);
                this.scene.add(fillLight);
            }
            
            setupControls() {
                const canvas = this.renderer.domElement;
                
                canvas.addEventListener('mousedown', (e) => {
                    this.mouseDown = true;
                    this.mouseButton = e.button;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    e.preventDefault();
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.mouseDown = false;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!this.mouseDown) return;
                    
                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;
                    
                    if (this.mouseButton === 0) { // å·¦é”® - æ—‹è½¬
                        this.rotateCamera(deltaX, deltaY);
                    } else if (this.mouseButton === 2) { // å³é”® - ç§»åŠ¨
                        this.moveCamera(deltaX, deltaY);
                    }
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                });
                
                canvas.addEventListener('wheel', (e) => {
                    this.zoomCamera(e.deltaY);
                    e.preventDefault();
                });
                
                canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // æŒ‰é’®äº‹ä»¶
                document.getElementById('explodeBtn').addEventListener('click', () => {
                    this.explodeBuilding();
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetScene();
                });
                
                document.getElementById('cameraBtn').addEventListener('click', () => {
                    this.switchCamera();
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            createGround() {
                // è§†è§‰åœ°é¢
                const groundGeometry = new THREE.PlaneGeometry(80, 80);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.9
                });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // ç‰©ç†åœ°é¢
                const groundShape = new CANNON.Plane();
                this.groundBody = new CANNON.Body({ mass: 0, material: this.concreteMaterial });
                this.groundBody.addShape(groundShape);
                this.groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.world.addBody(this.groundBody);
            }
            
            createBuilding() {
                const radius = 20 / (2 * Math.PI) * 1.05; // è½»å¾®é‡å ç¡®ä¿ç´§å¯†è´´åˆ
                const blockSize = 1;
                const blocksPerLayer = 20;
                const layers = 60;
                
                this.blocks = [];
                
                // åˆ›å»ºæ–¹å—å‡ ä½•ä½“å’Œææ–™
                const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                const blockMaterial = new THREE.MeshLambertMaterial({ color: 0xF5DEB3 });
                
                for (let layer = 0; layer < layers; layer++) {
                    const y = layer * blockSize + blockSize / 2;
                    // æ¯å±‚é”™å¼€50%æ’åˆ—
                    const angleOffset = (layer % 2) * (Math.PI / blocksPerLayer);
                    
                    for (let i = 0; i < blocksPerLayer; i++) {
                        const angle = (i / blocksPerLayer) * Math.PI * 2 + angleOffset;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;
                        
                        // åˆ›å»ºè§†è§‰æ–¹å—
                        const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial);
                        blockMesh.position.set(x, y, z);
                        blockMesh.castShadow = true;
                        blockMesh.receiveShadow = true;
                        this.scene.add(blockMesh);
                        
                        // åˆ›å»ºç‰©ç†æ–¹å—
                        const blockShape = new CANNON.Box(new CANNON.Vec3(blockSize/2, blockSize/2, blockSize/2));
                        const blockBody = new CANNON.Body({ 
                            mass: 1,
                            material: this.brickMaterial,
                            sleepSpeedLimit: 0.1,
                            sleepTimeLimit: 0.5
                        });
                        blockBody.addShape(blockShape);
                        blockBody.position.set(x, y, z);
                        
                        // åˆå§‹åŒ–æ—¶è®©æ–¹å—ç¡çœ 
                        blockBody.sleep();
                        
                        this.world.addBody(blockBody);
                        
                        this.blocks.push({
                            mesh: blockMesh,
                            body: blockBody,
                            layer: layer,
                            index: i,
                            exploded: false
                        });
                    }
                }
                
                document.getElementById('blockCount').textContent = this.blocks.length;
                
                // è®©ç‰©ç†ä¸–ç•Œç¨³å®šå‡ æ­¥
                for (let i = 0; i < 100; i++) {
                    this.world.step(1/60);
                }
            }
            
            setupParticleSystem() {
                // çƒŸé›¾ç²’å­
                const smokeGeometry = new THREE.BufferGeometry();
                const smokePositions = [];
                const smokeColors = [];
                const smokeCount = 500;
                
                for (let i = 0; i < smokeCount; i++) {
                    smokePositions.push(0, 0, 0);
                    smokeColors.push(0.5, 0.5, 0.5);
                }
                
                smokeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(smokePositions, 3));
                smokeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(smokeColors, 3));
                
                const smokeMaterial = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.smokeSystem = new THREE.Points(smokeGeometry, smokeMaterial);
                this.scene.add(this.smokeSystem);
                
                // åˆå§‹åŒ–çƒŸé›¾ç²’å­æ•°æ®
                for (let i = 0; i < smokeCount; i++) {
                    this.smokeParticles.push({
                        position: new THREE.Vector3(0, 0, 0),
                        velocity: new THREE.Vector3(0, 0, 0),
                        life: 0,
                        maxLife: Math.random() * 3 + 2,
                        size: Math.random() * 3 + 1,
                        active: false
                    });
                }
            }
            
            explodeBuilding() {
                if (this.exploded) return;
                
                this.exploded = true;
                document.getElementById('explodeBtn').disabled = true;
                document.getElementById('buildingStatus').textContent = 'çˆ†ç‚¸ä¸­...';
                
                // æ‰¾åˆ°ç¬¬1å±‚æœ€å³ä¾§çš„æ–¹å—
                const firstLayerBlocks = this.blocks.filter(block => block.layer === 0);
                let rightmostBlock = firstLayerBlocks[0];
                let maxX = rightmostBlock.body.position.x;
                
                firstLayerBlocks.forEach(block => {
                    if (block.body.position.x > maxX) {
                        maxX = block.body.position.x;
                        rightmostBlock = block;
                    }
                });
                
                const explosionCenter = rightmostBlock.body.position;
                const explosionRadius = 2;
                const explosionForce = 5;
                
                // å”¤é†’æ‰€æœ‰æ–¹å—
                this.blocks.forEach(block => {
                    block.body.wakeUp();
                });
                
                // å¯¹çˆ†ç‚¸èŒƒå›´å†…çš„æ–¹å—æ–½åŠ åŠ›
                this.blocks.forEach(block => {
                    const distance = explosionCenter.distanceTo(block.body.position);
                    if (distance <= explosionRadius) {
                        const direction = block.body.position.clone().vsub(explosionCenter);
                        if (direction.length() === 0) {
                            direction.set(Math.random() - 0.5, Math.random(), Math.random() - 0.5);
                        }
                        direction.normalize();
                        
                        const force = direction.scale(explosionForce * (1 - distance / explosionRadius));
                        force.y += 2; // å‘ä¸Šçš„åŠ›
                        
                        block.body.applyImpulse(force, block.body.position);
                        block.exploded = true;
                    }
                });
                
                // å¯åŠ¨ç²’å­æ•ˆæœ
                this.startParticleEffect(explosionCenter);
                
                // çˆ†ç‚¸å…‰æ•ˆ
                this.createExplosionLight(explosionCenter);
                
                setTimeout(() => {
                    document.getElementById('buildingStatus').textContent = 'å·²å€’å¡Œ';
                }, 2000);
            }
            
            startParticleEffect(center) {
                // æ¿€æ´»çƒŸé›¾ç²’å­
                this.smokeParticles.forEach((particle, index) => {
                    if (index < 200) { // åªæ¿€æ´»éƒ¨åˆ†ç²’å­
                        particle.position.copy(center);
                        particle.position.x += (Math.random() - 0.5) * 4;
                        particle.position.z += (Math.random() - 0.5) * 4;
                        particle.velocity.set(
                            (Math.random() - 0.5) * 2,
                            Math.random() * 3 + 1,
                            (Math.random() - 0.5) * 2
                        );
                        particle.life = 0;
                        particle.active = true;
                    }
                });
            }
            
            createExplosionLight(center) {
                const explosionLight = new THREE.PointLight(0xff4400, 2, 50);
                explosionLight.position.copy(center);
                this.scene.add(explosionLight);
                
                // å…‰çº¿æ¸å¼±æ•ˆæœ
                let intensity = 2;
                const fadeInterval = setInterval(() => {
                    intensity -= 0.1;
                    explosionLight.intensity = Math.max(0, intensity);
                    
                    if (intensity <= 0) {
                        this.scene.remove(explosionLight);
                        clearInterval(fadeInterval);
                    }
                }, 50);
            }
            
            updateParticles() {
                if (!this.exploded) return;
                
                const positions = this.smokeSystem.geometry.attributes.position.array;
                const colors = this.smokeSystem.geometry.attributes.color.array;
                
                this.smokeParticles.forEach((particle, index) => {
                    if (!particle.active) return;
                    
                    particle.life += 0.016;
                    
                    if (particle.life >= particle.maxLife) {
                        particle.active = false;
                        positions[index * 3] = 0;
                        positions[index * 3 + 1] = -1000; // éšè—ç²’å­
                        positions[index * 3 + 2] = 0;
                        return;
                    }
                    
                    // æ›´æ–°ä½ç½®
                    particle.position.add(particle.velocity.clone().multiplyScalar(0.016));
                    particle.velocity.y -= 0.5 * 0.016; // é‡åŠ›å½±å“
                    particle.velocity.multiplyScalar(0.98); // ç©ºæ°”é˜»åŠ›
                    
                    positions[index * 3] = particle.position.x;
                    positions[index * 3 + 1] = particle.position.y;
                    positions[index * 3 + 2] = particle.position.z;
                    
                    // æ›´æ–°é¢œè‰²å’Œé€æ˜åº¦
                    const life = particle.life / particle.maxLife;
                    const opacity = 1 - life;
                    colors[index * 3] = 0.5 + life * 0.3;
                    colors[index * 3 + 1] = 0.5 + life * 0.3;
                    colors[index * 3 + 2] = 0.5 + life * 0.3;
                });
                
                this.smokeSystem.geometry.attributes.position.needsUpdate = true;
                this.smokeSystem.geometry.attributes.color.needsUpdate = true;
            }
            
            rotateCamera(deltaX, deltaY) {
                const target = new THREE.Vector3(0, 25, 0);
                const spherical = new THREE.Spherical();
                const offset = this.camera.position.clone().sub(target);
                
                spherical.setFromVector3(offset);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                offset.setFromSpherical(spherical);
                this.camera.position.copy(target).add(offset);
                this.camera.lookAt(target);
            }
            
            moveCamera(deltaX, deltaY) {
                const target = new THREE.Vector3(0, 25, 0);
                const right = new THREE.Vector3();
                const up = new THREE.Vector3(0, 1, 0);
                
                this.camera.getWorldDirection(right);
                right.cross(up).normalize();
                up.crossVectors(right, this.camera.getWorldDirection(new THREE.Vector3()));
                
                const movement = right.multiplyScalar(-deltaX * 0.1).add(up.multiplyScalar(deltaY * 0.1));
                this.camera.position.add(movement);
                target.add(movement);
                this.camera.lookAt(target);
            }
            
            zoomCamera(delta) {
                const target = new THREE.Vector3(0, 25, 0);
                const direction = this.camera.position.clone().sub(target);
                const distance = direction.length();
                
                direction.normalize();
                const newDistance = Math.max(10, Math.min(150, distance + delta * 0.1));
                this.camera.position.copy(target).add(direction.multiplyScalar(newDistance));
            }
            
            switchCamera() {
                this.cameraMode = (this.cameraMode + 1) % this.cameraPositions.length;
                const pos = this.cameraPositions[this.cameraMode];
                
                this.camera.position.set(...pos.pos);
                this.camera.lookAt(...pos.target);
            }
            
            resetScene() {
                // æ¸…ç†ç°æœ‰åœºæ™¯
                this.blocks.forEach(block => {
                    this.scene.remove(block.mesh);
                    this.world.remove(block.body);
                });
                
                this.blocks = [];
                this.exploded = false;
                
                // é‡æ–°åˆ›å»ºå»ºç­‘
                this.createBuilding();
                
                // é‡ç½®æ§åˆ¶
                document.getElementById('explodeBtn').disabled = false;
                document.getElementById('buildingStatus').textContent = 'ç¨³å®š';
                
                // é‡ç½®ç²’å­
                this.smokeParticles.forEach(particle => {
                    particle.active = false;
                });
                
                // é‡ç½®ç›¸æœº
                this.cameraMode = 0;
                this.switchCamera();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // æ›´æ–°ç‰©ç†ä¸–ç•Œ
                this.world.step(1/60);
                
                // åŒæ­¥è§†è§‰å’Œç‰©ç†
                this.blocks.forEach(block => {
                    block.mesh.position.copy(block.body.position);
                    block.mesh.quaternion.copy(block.body.quaternion);
                });
                
                // æ›´æ–°ç²’å­
                this.updateParticles();
                
                // æ¸²æŸ“
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // å¯åŠ¨åº”ç”¨
        window.addEventListener('load', () => {
            new BuildingDemolition();
        });
    </script>
</body>
</html>
