<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då»ºç­‘æ‹†é™¤æ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls h3 {
            margin-bottom: 15px;
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .btn {
            display: block;
            width: 200px;
            padding: 12px 20px;
            margin: 10px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.explode {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        .btn.explode:hover {
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .btn.explode:disabled {
            background: #666;
            cursor: not-allowed;
            box-shadow: none;
        }

        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info p {
            margin: 5px 0;
            opacity: 0.8;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #fff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading" id="loading">æ­£åœ¨åŠ è½½åœºæ™¯...</div>
        
        <div class="controls">
            <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>
            <button class="btn explode" id="explodeBtn">ğŸ’¥ å¼•çˆ†å»ºç­‘</button>
            <button class="btn" id="resetBtn">ğŸ”„ é‡ç½®åœºæ™¯</button>
            <button class="btn" id="cameraBtn">ğŸ“· åˆ‡æ¢è§†è§’</button>
        </div>

        <div class="info">
            <p>ğŸ–±ï¸ é¼ æ ‡å·¦é”®ï¼šæ—‹è½¬è§†è§’</p>
            <p>ğŸ–±ï¸ é¼ æ ‡å³é”®ï¼šå¹³ç§»è§†è§’</p>
            <p>ğŸ–±ï¸ æ»šè½®ï¼šç¼©æ”¾è§†è§’</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // åœºæ™¯å˜é‡
        let scene, camera, renderer, controls;
        let world;
        let buildingBodies = [];
        let buildingMeshes = [];
        let particleSystems = [];
        let exploded = false;
        let cameraAngle = 0;
        let ambientLight, directionalLight;

        // ç‰©ç†å‚æ•°
        const BLOCK_SIZE = 1;
        const BUILDING_RADIUS = 10;
        const BUILDING_HEIGHT = 60;
        const BLOCKS_PER_LAYER = 20;
        const GRAVITY = -9.82;

        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x333333, 50, 200);

            // ç›¸æœºè®¾ç½®
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(40, 30, 40);
            camera.lookAt(0, 20, 0);

            // æ¸²æŸ“å™¨è®¾ç½®
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x222222);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ§åˆ¶å™¨è®¾ç½®
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.minDistance = 20;
            controls.maxDistance = 100;

            // ç¯å…‰è®¾ç½®
            ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // æ·»åŠ åŠçƒå…‰
            const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x333333, 0.3);
            scene.add(hemiLight);
        }

        // åˆå§‹åŒ–Cannon.jsç‰©ç†ä¸–ç•Œ
        function initCannon() {
            world = new CANNON.World();
            world.gravity.set(0, GRAVITY, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.defaultContactMaterial.contactEquationStiffness = 1e8;
            world.defaultContactMaterial.contactEquationRelaxation = 3;

            // åˆ›å»ºé«˜æ‘©æ“¦åŠ›ã€ä½å¼¹æ€§çš„æ¥è§¦ææ–™
            const buildingMaterial = new CANNON.Material('building');
            const groundMaterial = new CANNON.Material('ground');
            
            const buildingGroundContact = new CANNON.ContactMaterial(
                buildingMaterial,
                groundMaterial,
                {
                    friction: 0.8,
                    restitution: 0.05
                }
            );
            
            const buildingBuildingContact = new CANNON.ContactMaterial(
                buildingMaterial,
                buildingMaterial,
                {
                    friction: 0.9,
                    restitution: 0.03
                }
            );
            
            world.addContactMaterial(buildingGroundContact);
            world.addContactMaterial(buildingBuildingContact);
        }

        // åˆ›å»ºåœ°é¢
        function createGround() {
            // Three.jsåœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                roughness: 0.8
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Cannon.jsåœ°é¢
            const groundShape = new CANNON.Box(new CANNON.Vec3(40, 0.1, 40));
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                material: new CANNON.Material('ground')
            });
            groundBody.position.set(0, -0.1, 0);
            world.add(groundBody);
        }

        // åˆ›å»ºå»ºç­‘
        function createBuilding() {
            const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const blockMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xD2B48C,
                roughness: 0.7
            });

            const blockShape = new CANNON.Box(new CANNON.Vec3(
                BLOCK_SIZE / 2,
                BLOCK_SIZE / 2,
                BLOCK_SIZE / 2
            ));

            const buildingMaterial = new CANNON.Material('building');

            for (let layer = 0; layer < BUILDING_HEIGHT; layer++) {
                const offset = (layer % 2) * (Math.PI / BLOCKS_PER_LAYER);
                
                for (let i = 0; i < BLOCKS_PER_LAYER; i++) {
                    const angle = (i / BLOCKS_PER_LAYER) * Math.PI * 2 + offset;
                    const x = Math.cos(angle) * BUILDING_RADIUS;
                    const z = Math.sin(angle) * BUILDING_RADIUS;
                    const y = layer * BLOCK_SIZE + BLOCK_SIZE / 2;

                    // Three.jsæ–¹å—
                    const blockMesh = new THREE.Mesh(blockGeometry, blockMaterial);
                    blockMesh.position.set(x, y, z);
                    blockMesh.castShadow = true;
                    blockMesh.receiveShadow = true;
                    scene.add(blockMesh);
                    buildingMeshes.push(blockMesh);

                    // Cannon.jsæ–¹å—
                    const blockBody = new CANNON.Body({
                        mass: 1,
                        shape: blockShape,
                        position: new CANNON.Vec3(x, y, z),
                        material: buildingMaterial
                    });
                    
                    // è®¾ç½®ç¡çœ å‚æ•°
                    blockBody.allowSleep = true;
                    blockBody.sleepSpeedLimit = 0.01;
                    blockBody.sleepTimeLimit = 0.1;
                    
                    world.add(blockBody);
                    buildingBodies.push(blockBody);
                }
            }

            // è®©ç‰©ç†ä¸–ç•Œç¨³å®šå‡ æ­¥
            for (let i = 0; i < 10; i++) {
                world.step(1/60);
            }

            // å°†æ‰€æœ‰æ–¹å—è®¾ç½®ä¸ºç¡çœ çŠ¶æ€
            buildingBodies.forEach(body => {
                body.sleep();
            });
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem(position, color, particleCount) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;

                velocities[i * 3] = (Math.random() - 0.5) * 2;
                velocities[i * 3 + 1] = Math.random() * 3 + 2;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;

                lifetimes[i] = Math.random() * 2 + 1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(geometry, material);
            particleSystem.userData = {
                velocities: velocities,
                lifetimes: lifetimes,
                maxLifetime: 3
            };

            scene.add(particleSystem);
            particleSystems.push(particleSystem);
        }

        // æ›´æ–°ç²’å­ç³»ç»Ÿ
        function updateParticles(deltaTime) {
            particleSystems = particleSystems.filter(system => {
                const positions = system.geometry.attributes.position.array;
                const velocities = system.userData.velocities;
                const lifetimes = system.userData.lifetimes;
                const maxLifetime = system.userData.maxLifetime;

                let allDead = true;

                for (let i = 0; i < lifetimes.length; i++) {
                    if (lifetimes[i] > 0) {
                        allDead = false;
                        lifetimes[i] -= deltaTime;

                        positions[i * 3] += velocities[i * 3] * deltaTime;
                        positions[i * 3 + 1] += velocities[i * 3 + 1] * deltaTime;
                        positions[i * 3 + 2] += velocities[i * 3 + 2] * deltaTime;

                        velocities[i * 3 + 1] -= 9.82 * deltaTime;

                        const opacity = lifetimes[i] / maxLifetime;
                        system.material.opacity = opacity * 0.8;
                    }
                }

                system.geometry.attributes.position.needsUpdate = true;

                if (allDead) {
                    scene.remove(system);
                    return false;
                }

                return true;
            });
        }

        // çˆ†ç‚¸æ•ˆæœ
        function explode() {
            if (exploded) return;
            exploded = true;

            // ç¦ç”¨çˆ†ç‚¸æŒ‰é’®
            document.getElementById('explodeBtn').disabled = true;

            // çˆ†ç‚¸ç‚¹ä½ç½®ï¼ˆç¬¬1å±‚æœ€å³ä¾§ï¼‰
            const explosionPos = new CANNON.Vec3(BUILDING_RADIUS, BLOCK_SIZE / 2, 0);
            const explosionRadius = 2;
            const explosionForce = 5;

            // é—ªå…‰æ•ˆæœ
            const flashLight = new THREE.PointLight(0xffffff, 10, 50);
            flashLight.position.set(explosionPos.x, explosionPos.y, explosionPos.z);
            scene.add(flashLight);

            // åˆ›å»ºçˆ†ç‚¸ç²’å­
            createParticleSystem(
                new THREE.Vector3(explosionPos.x, explosionPos.y, explosionPos.z),
                0xff6600,
                200
            );

            // çƒŸå°˜ç²’å­
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createParticleSystem(
                        new THREE.Vector3(
                            explosionPos.x + (Math.random() - 0.5) * 5,
                            explosionPos.y + Math.random() * 5,
                            explosionPos.z + (Math.random() - 0.5) * 5
                        ),
                        0x666666,
                        100
                    );
                }, i * 100);
            }

            // åº”ç”¨çˆ†ç‚¸åŠ›
            buildingBodies.forEach((body, index) => {
                body.wakeUp();
                
                const distance = body.position.distanceTo(explosionPos);
                
                if (distance < explosionRadius) {
                    const force = explosionForce * (1 - distance / explosionRadius);
                    const direction = new CANNON.Vec3();
                    body.position.vsub(explosionPos, direction);
                    direction.normalize();
                    direction.scale(force, direction);
                    body.applyImpulse(direction, body.position);
                    
                    // æ·»åŠ æ—‹è½¬
                    body.angularVelocity.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );
                }
            });

            // æ¸æš—æ•ˆæœ
            setTimeout(() => {
                scene.remove(flashLight);
                ambientLight.intensity = 0.2;
                directionalLight.intensity = 0.4;
                
                // çƒŸå°˜é®æŒ¡æ•ˆæœ
                const fogDensity = 0.01;
                const fadeInterval = setInterval(() => {
                    if (scene.fog.far > 80) {
                        scene.fog.far -= 2;
                    } else {
                        clearInterval(fadeInterval);
                    }
                }, 100);
            }, 200);

            // é€æ¸æ¢å¤å…‰ç…§
            setTimeout(() => {
                const restoreInterval = setInterval(() => {
                    if (ambientLight.intensity < 0.5) {
                        ambientLight.intensity += 0.01;
                        directionalLight.intensity += 0.02;
                    } else {
                        clearInterval(restoreInterval);
                    }
                }, 50);
            }, 3000);
        }

        // é‡ç½®åœºæ™¯
        function resetScene() {
            // æ¸…é™¤ç°æœ‰å»ºç­‘
            buildingBodies.forEach(body => world.remove(body));
            buildingMeshes.forEach(mesh => scene.remove(mesh));
            buildingBodies = [];
            buildingMeshes = [];

            // æ¸…é™¤ç²’å­ç³»ç»Ÿ
            particleSystems.forEach(system => scene.remove(system));
            particleSystems = [];

            // é‡ç½®å…‰ç…§
            ambientLight.intensity = 0.5;
            directionalLight.intensity = 0.8;
            scene.fog.far = 200;

            // é‡æ–°åˆ›å»ºå»ºç­‘
            createBuilding();

            // é‡ç½®çŠ¶æ€
            exploded = false;
            document.getElementById('explodeBtn').disabled = false;
        }

        // åˆ‡æ¢ç›¸æœºè§†è§’
        function switchCamera() {
            cameraAngle = (cameraAngle + 1) % 4;
            
            switch(cameraAngle) {
                case 0:
                    camera.position.set(40, 30, 40);
                    break;
                case 1:
                    camera.position.set(-40, 30, 40);
                    break;
                case 2:
                    camera.position.set(0, 50, 60);
                    break;
                case 3:
                    camera.position.set(40, 30, -40);
                    break;
            }
            
            camera.lookAt(0, 20, 0);
            controls.update();
        }

        // åŠ¨ç”»å¾ªç¯
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // æ›´æ–°ç‰©ç†ä¸–ç•Œ
            world.step(1/60);

            // åŒæ­¥Three.jså’ŒCannon.js
            buildingBodies.forEach((body, index) => {
                if (buildingMeshes[index]) {
                    buildingMeshes[index].position.copy(body.position);
                    buildingMeshes[index].quaternion.copy(body.quaternion);
                }
            });

            // æ›´æ–°ç²’å­ç³»ç»Ÿ
            updateParticles(deltaTime);

            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();

            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åˆå§‹åŒ–
        function init() {
            initThree();
            initCannon();
            createGround();
            createBuilding();

            // éšè—åŠ è½½æç¤º
            document.getElementById('loading').style.display = 'none';

            // äº‹ä»¶ç›‘å¬
            document.getElementById('explodeBtn').addEventListener('click', explode);
            document.getElementById('resetBtn').addEventListener('click', resetScene);
            document.getElementById('cameraBtn').addEventListener('click', switchCamera);
            window.addEventListener('resize', onWindowResize);

            // å¼€å§‹åŠ¨ç”»
            animate(0);
        }

        // å¯åŠ¨åº”ç”¨
        window.addEventListener('load', init);
    </script>
</body>
</html>
