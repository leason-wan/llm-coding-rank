```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då»ºç­‘æ‹†é™¤æ¼”ç¤º</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #111;
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .camera-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="controls">
            <button onclick="explode()">ğŸ§¨ çˆ†ç‚¸</button>
            <button onclick="resetScene()">ğŸ”„ é‡ç½®</button>
            <button onclick="switchCamera()">ğŸ“· åˆ‡æ¢è§†è§’</button>
        </div>
        <div class="camera-info">
            é¼ æ ‡æ“ä½œï¼šå·¦é”®æ—‹è½¬ï¼Œå³é”®å¹³ç§»ï¼Œæ»šè½®ç¼©æ”¾
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let world;
        let building = [];
        let particles = [];
        let explosionPoint;
        let controls = {
            mouseX: 0,
            mouseY: 0,
            mouseDown: false,
            rightClick: false,
            rotation: 0
        };
        let cameraMode = 0;
        
        // åœºæ™¯åˆå§‹åŒ–
        function init() {
            // ç‰©ç†ä¸–ç•Œ
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.allowSleep = true;
            
            // Three.js åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x222222, 10, 200);
            
            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 50);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // å…‰ç…§
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // åœ°é¢
            createGround();
            
            // åˆ›å»ºå»ºç­‘
            createBuilding();
            
            // é¼ æ ‡æ§åˆ¶
            setupControls();
            
            // å¼€å§‹åŠ¨ç”»
            animate();
        }
        
        // åˆ›å»ºåœ°é¢
        function createGround() {
            const groundGeometry = new THREE.BoxGeometry(80, 1, 80);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.position.y = -0.5;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);
            
            const groundShape = new CANNON.Box(new CANNON.Vec3(40, 0.5, 40));
            const groundBody = new CANNON.Body({
                mass: 0,
                shape: groundShape,
                position: new CANNON.Vec3(0, -0.5, 0)
            });
            world.add(groundBody);
        }
        
        // åˆ›å»ºå»ºç­‘
        function createBuilding() {
            building = [];
            const baseRadius = 4;
            const blockSize = 0.8;
            const blocksPerLevel = 20;
            const levels = 60;
            
            const brickMaterial = new THREE.MeshLambertMaterial({ color: 0xD4B896 });
            
            // åˆ›å»ºæ¥è§¦ææ–™ï¼ˆé«˜æ‘©æ“¦ï¼Œä½å¼¹æ€§ï¼‰
            const contactMaterial = new CANNON.ContactMaterial(
                new CANNON.Material('brick'),
                new CANNON.Material('brick'),
                {
                    friction: 0.8,
                    restitution: 0.05
                }
            );
            world.addContactMaterial(contactMaterial);
            
            for (let level = 0; level < levels; level++) {
                const currentAngle = (level % 2) * (Math.PI / blocksPerLevel);
                const yPos = level * blockSize;
                
                for (let i = 0; i < blocksPerLevel; i++) {
                    const angle = (2 * Math.PI / blocksPerLevel) * i + currentAngle;
                    const xPos = baseRadius * Math.cos(angle);
                    const zPos = baseRadius * Math.sin(angle);
                    
                    // åˆ›å»ºæ–¹å—
                    const boxGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
                    const boxMesh = new THREE.Mesh(boxGeometry, brickMaterial);
                    boxMesh.position.set(xPos, yPos, zPos);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    scene.add(boxMesh);
                    
                    // ç‰©ç†ä½“
                    const boxShape = new CANNON.Box(new CANNON.Vec3(blockSize/2, blockSize/2, blockSize/2));
                    const boxBody = new CANNON.Body({
                        mass: 1,
                        shape: boxShape,
                        position: new CANNON.Vec3(xPos, yPos, zPos),
                        material: new CANNON.Material('brick')
                    });
                    
                    // è®¾ç½®çº¿æ€§é˜»å°¼ï¼Œå‡å°‘æ‘‡æ‘†
                    boxBody.linearDamping = 0.1;
                    boxBody.angularDamping = 0.1;
                    
                    // åˆå§‹çŠ¶æ€ä¸ºç¡çœ 
                    boxBody.sleep();
                    boxBody.allowSleep = true;
                    
                    world.add(boxBody);
                    
                    building.push({ mesh: boxMesh, body: boxBody });
                }
            }
            
            // çˆ†ç‚¸ç‚¹
            explosionPoint = building[10].body.position.clone();
            explosionPoint.x += 2;
        }
        
        // çˆ†ç‚¸æ•ˆæœ
        function explode() {
            const explosionForce = 8;
            const explosionRadius = 2;
            
            building.forEach(({ mesh, body }) => {
                const distance = body.position.distanceTo(explosionPoint);
                if (distance < explosionRadius) {
                    body.wakeUp();
                    const force = new CANNON.Vec3(
                        (body.position.x - explosionPoint.x) / distance,
                        1,
                        (body.position.z - explosionPoint.z) / distance
                    );
                    force.scale(explosionForce * (1 - distance / explosionRadius), force);
                    body.applyImpulse(force);
                } else if (distance < 6) {
                    body.wakeUp();
                }
            });
            
            // åˆ›å»ºçˆ†ç‚¸ç²’å­
            createExplosionParticles();
            createSmoke();
            
            // å…‰ç…§å˜åŒ–
            updateLighting();
        }
        
        // åˆ›å»ºçˆ†ç‚¸ç²’å­
        function createExplosionParticles() {
            const particleCount = 30;
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xFF4444 });
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(explosionPoint);
                particle.position.y += 0.5;
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 20
                );
                
                scene.add(particle);
                
                particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 1.0
                });
            }
        }
        
        // åˆ›å»ºçƒŸé›¾
        function createSmoke() {
            const smokeCount = 50;
            const smokeGeometry = new THREE.SphereGeometry(1, 8, 8);
            const smokeMaterial = new THREE.MeshBasicMaterial({
                color: 0x666666,
                transparent: true,
                opacity: 0.5
            });
            
            for (let i = 0; i < smokeCount; i++) {
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.copy(explosionPoint);
                smoke.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 4,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 4
                ));
                
                scene.add(smoke);
                
                particles.push({
                    mesh: smoke,
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 3 + 1,
                        (Math.random() - 0.5) * 2
                    ),
                    life: 1.0,
                    isSmoke: true
                });
            }
        }
        
        // æ›´æ–°å…‰ç…§
        function updateLighting() {
            const flash = new THREE.PointLight(0xFF4400, 5, 50);
            flash.position.copy(explosionPoint);
            scene.add(flash);
            
            setTimeout(() => {
                scene.remove(flash);
            }, 100);
        }
        
        // é‡ç½®åœºæ™¯
        function resetScene() {
            building.forEach(({ mesh, body }) => {
                scene.remove(mesh);
                world.remove(body);
            });
            
            particles.forEach(({ mesh }) => {
                scene.remove(mesh);
            });
            particles = [];
            
            createBuilding();
        }
        
        // åˆ‡æ¢ç›¸æœºè§†è§’
        function switchCamera() {
            cameraMode = (cameraMode + 1) % 3;
            
            switch(cameraMode) {
                case 0:
                    camera.position.set(30, 30, 50);
                    camera.lookAt(0, 20, 0);
                    break;
                case 1:
                    camera.position.set(0, 60, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 2:
                    camera.position.set(50, 10, 0);
                    camera.lookAt(0, 15, 0);
                    break;
            }
        }
        
        // é¼ æ ‡æ§åˆ¶
        function setupControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (e.button === 0) controls.mouseDown = true;
                if (e.button === 2) controls.rightClick = true;
            });
            
            renderer.domElement.addEventListener('mouseup', (e) => {
                if (e.button === 0) controls.mouseDown = false;
                if (e.button === 2) controls.rightClick = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (controls.mouseDown && !controls.rightClick) {
                    controls.rotation += e.movementX * 0.01;
                    camera.position.x = Math.cos(controls.rotation) * 80;
                    camera.position.z = Math.sin(controls.rotation) * 80;
                    camera.lookAt(0, 15, 0);
                } else if (controls.rightClick) {
                    camera.position.x -= e.movementX * 0.1;
                    camera.position.z -= e.movementY * 0.1;
                    camera.lookAt(0, 15, 0);
                }
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
            });
            
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç‰©ç†ä¸–ç•Œ
            world.step(1/60);
            
            // åŒæ­¥ç‰©ç†å’Œæ¸²æŸ“
            building.forEach(({ mesh, body }) => {
                mesh.position.copy(body.position);
                mesh.quaternion.copy(body.quaternion);
            });
            
            // æ›´æ–°ç²’å­
            particles = particles.filter(p => {
                p.life -= 0.01;
                p.mesh.position.add(p.velocity.clone().multiplyScalar(0.016));
                if (p.isSmoke) {
                    p.mesh.scale.multiplyScalar(1.02);
                    p.mesh.material.opacity *= 0.98;
                }
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    return false;
                }
                return true;
            });
            
            renderer.render(scene, camera);
        }
        
        // çª—å£è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // åˆå§‹åŒ–
        init();
    </script>
</body>
</html>
```